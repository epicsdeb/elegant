% How to create this document on UNIX systems:
%   latex elegant
%   dvi2ps elegant | lpr [-P<postscript-printer-name>]
%
\documentclass[11pt]{article}
\usepackage{html}
\usepackage{longtable}
\usepackage{epsfig}
\usepackage{subfigure} 
\pagestyle{plain}
%\voffset=-0.75in
\newenvironment{req}{\begin{equation} \rm}{\end{equation}}
\setlength{\topmargin}{0.15 in}
\setlength{\oddsidemargin}{0 in}
\setlength{\evensidemargin}{0 in} % not applicable anyway
\setlength{\textwidth}{6.5 in}
\setlength{\headheight}{-0.5 in} % for 11pt font size
%\setlength{\footheight}{0 in}
\setlength{\textheight}{9 in}
\begin{document}

\title{User's Manual for {\tt elegant}}
\author{Program Version 23.2\\Advanced Photon Source\\Michael Borland\\ \date{\today}}
\maketitle

Note: another source of help for {\tt elegant} is the on-line
\htmladdnormallink{forum}{https://www.aps.anl.gov/Accelerator_Systems_Division/Operations_Analysis/phpBB3}.
Users are encouraged to join and participate.  At minimum, users should subscribe to the ``Bugs'' topic,
since this is where bug notifications are posted.  Contrary to previous practise, we will no longer announce
bugs via email.

A \htmladdnormallink{brief overview}{http://www.aps.anl.gov/elegant.html} of {\tt elegant} is also available, which introduces the capabilities
at a high-level.

\section{Highlights of What's New in Version 24.0}

Here is a summary of what's changed since release 23.1:

\subsection{Bug Fixes for Elements}

\begin{itemize}
\item The third-order matrix for quadrupoles (used by the {\tt QUAD} element for tracking or by
  {\tt KQUAD} for analysis) was improved to include all the terms.  The previous version had only
  the most obvious terms.
\item Parallel elegant: The fiducial time wasn't computed correctly for the {\tt MBUMPER} element, but is now fixed.
\item Fixed a bug in {\tt CSRCSBEND} elements that resulted in incorrect edge angles when reflection was used.  This was reported
 by R. Hajima (JAEA).
\item Fixed the fact that the {\tt TRFMODE} element ignored the {\tt RECORD} parameter (which was supposed to provide output
  of the mode voltages).
\end{itemize}

\subsection{Bug Fixes for Commands}
\begin{itemize}
\item Optimization now allows access to the response matrix elements for a transport line.  This deficiency was pointed
  out by C. Tennant (TJNAF).
\item In some cases, the {\tt failed} semaphore file would not be created when a run failed.  This has been rectified.
\item Fixed some problems with output from orbit correction.  In particular, there was no output of the orbit before
  correction.  It is uncertain when this bug was introduced.
\item The \verb|final_pass| parameter of the \verb|run_setup| command is more efficient, in that only the required
  moments computations are performed.  This has a significant impact run time.
\item The \verb|bunched_beam| command was generating incorrect results when \verb|momentum_chirp| was non-zero and
  the dispersion parameters were non-zero.  This was fixed.
\item The performance of the \verb|load_parameters| command was improved in that the user can now control what is
  done in the case of duplicate settings for a given parameter.  This was done by Y. Wang (ANL).
\end{itemize}

\subsection{New and Modified Elements}
\begin{itemize}
\item The {\tt FTABLE} element was added, which allows integration of particle trajectories through a 3D field table.  This was implemented
  by A. Xiao (ANL).
\item The {\tt ZTRANSVERSE} and {\tt TRWAKE} now have independent control of the 
  exponents for the drive and witness beam coordinates.  This allows, for example,
  simulation of quadrupole wakes, and was requested by Y.-C. Chae (ANL).
  The {\tt XPOWER} amd {\tt YPOWER} parameters were removed, which may break old
  input files.
\item Radiation from steering correctors ({\tt HKICK}, {\tt VKICK},
  and {\tt HVKICK}) are now included in computation of beam moments
  ({\tt moments\_output} command) and in element-by-element tracking
  (if requested).  However, they are not yet included in radiation integral computations.
\item The {\tt RFDF} element now has a matrix that is used for single-pass Twiss parameter computations and the like. This
  might be useful, for example, in designing an emittance exchange system.
\item The {\tt ECOL} and {\tt MAXAMP} elements now have a {\tt YEXPONENT} parameter. If non-zero, it overrides the {\tt EXPONENT}
  command and allows specifying a more general aperture shape. This was suggested by L. Emery (ANL).
\item The {\tt EMATRIX} element now has misalignment parameters.
\item The {\tt TWISS} element now has a {\tt DISABLE} parameter.
\item The {\tt LSRMDLTR} element now has a {\tt TILT} parameter.
\item The {\tt RFCW} element now has {\tt ZWAKE} and {\tt TRWAKE} parameters, which allow disabling the respective wakes.
\item The \verb|LOCK_PHASE| parameter was added to the {\tt RFCA} element, allowing locking the phase of a cavity to the beam.
\end{itemize}

\subsection{New and Modified Commands}
\begin{itemize}
\item The {\tt ramp\_elements} command was added.  It allows simplified ramping of essentially
 any numerical parameter of any element on a turn-by-turn basis.  This functionality was
 already provided by {\tt modulate\_elements}, but was more difficult to use in that form.
\item The \verb|frequency_map| command now directly supports frequency maps that are a function of 
  $x$, $y$, and $\delta$.  (In the past, variation of $\delta$ could be done using \verb|vary_elements|.)
\item The \verb|touschek_scatter| command now supports multi-pass tracking.  This was implemented by A. Xiao (ANL).
\item The $R_{6i}$ matrix elements now appear in the \verb|run_setup/final| output file, and can also be
  optimized.
\item The line-search mode for dynamic aperture determination now records the coordinates at which the boundary
  particles are lost.
\item The {\tt optimization\_variable} command has a new parameter, {\tt force\_inside}, which 
  allows forcing the initial value of the variable inside the boundaries set by the 
  {\tt lower\_limit} and {\tt upper\_limit} parameters.
\item The printed output from optimization now flags any variables that are close to the
  limits of the allowed range.
\item The logic of elegant was improved so that the correction loop cycles over orbit/trajectory, tune, and chromaticity in a more
  sensible way.  In the past, orbit/trajectory correction was not included in the tune/chromaticity loop, which could lead to
  convergence problems.
\item The output of the \verb|momentum_aperture| command now includes the element name and occurrence number.  This was
  implemented by A. Xiao (ANL).
\item It is now possible to optimize the values of radiation integrals at {\tt MARK} elements.
\end{itemize}

%\subsection{Other Changes}
%\begin{itemize}
%\end{itemize}

\subsection{Changes for Parallel Version Only}

This work was performed by Y. Wang (ANL).
\begin{itemize}
\item A new command, \verb|parallel_optimization_setup|, was added that provides access to parallel optimization. The methods include
  a single-objective genetic algorithm, parallel hybrid simplex optimization, and particle swarm optimization.  See the
  manual entry below for details.  
\item The {\tt RAMPP} element was parallelized.
\end{itemize}

\subsection{Changes to Related Programs and Files}

\begin{itemize}
\item {\tt sddsfindresonances}: The program now processes each page separately, so multi-page FMA files can be handled.
  Also added the ability to increase the number of multipoles.
\item {\tt sddsbrightness}: Added ability to take error factors from a file and multiply each harmonic by the specified factor.
  In the event that the brightness can't be computed, the corresponding rows are now filled in with 0, instead of crashing.
\item {\tt sddsfluxcurve}: Bugs were fixed related to use of the emittanceRatio parameter.
\item {\tt sddsurgent}: Fixed bugs in computation of spatial distribution for harmonic greater than 1.  Now correctly 
  computes K when the harmonic number is not 1 and the photon energy is given.
\item {\tt elegantRingAnalysis}: Added control over the number of processors used for FMA.  Added the ability to compute
  the kick aperture (kicker scan to find aperture) using parallel elegant.
\end{itemize}

\subsection{Known Bugs, Problems, and Limitations}
\begin{itemize}
\item Twiss output contains entries for the higher-order dispersion, tune shifts with amplitude, higher-order chromaticity, tune spreads
  due to chromaticity and amplitude, and resonance driving terms {\em even when these are not calculated}, which is potentially
  misleading.   The values are zero when the calculation is not requested.
\item Computation of closed orbits and Twiss parameters will not always include the effects of synchrotron
  radiation losses when these are imposed using {\tt SREFFECTS} elements.  See
  the documentation for {\tt SREFFECTS} for details.
\item Computation of beam moments does not include synchrotron radiation effects from \verb|CWIGGLER|,
  \verb|WIGGLER|, or \verb|UKICKMAP| elements.
\item The file created with the parameters field of \verb|run_setup| does not contain
  any non-numerical parameters of the lattice.
\item When \verb|transmute_elements| is used to turn a sextupole into a quadrupole, several problems are seen.
 Some of the quadrupole parameters are filled with garbage values.  When \verb|alter_elements| or
 \verb|save_lattice| are subsequently used, \verb|elegant| crashes.   These problems were reported by 
 V. Sajaev (ANL).
\item Computation of radiation integrals does not include the effect of steering magnets.
\end{itemize}

\section{Credits}

Contributors to {\tt elegant} include M. Borland, W. Guo, R. Soliday, V. Sajaev, Y. Wang, Y. Wu, and A. Xiao.
Contributors to related programs include M. Borland, R. Dejus, L. Emery, H. Shang, and Y. Wang.
R. Soliday is responsible for multi-platform builds and distribution.
Of course, we also appreciate the many suggestions, comments, and bug reports from users.

\section{Introduction}

{\tt elegant} stands for ``ELEctron Generation ANd Tracking,'' a
somewhat out-of-date description of a fully 6D accelerator program
that now does much more than generate particle distributions and track
them.  {\tt elegant}, written entirely in the C programming
language\cite{Kernighan}, uses a variant of the MAD\cite{MAD} input
format to describe accelerators, which may be either transport lines,
circular machines, or a combination thereof.  Program execution is
driven by commands in a namelist format.

This document describes the features available in {\tt elegant},
listing the commands and their arguments.  The differences between
{\tt elegant} and MAD formats for describing accelerators are listed.
A series of examples of {\tt elegant} input and output are given.
Finally, appendices are included describing the post-processing
programs.

\subsection{Program Philosophy}

For all its complexity, {\tt elegant} is not a stand-alone program.
For example, most of the output is not human-readable, and {\tt
elegant} itself has no graphics capabilities.  These tasks are handled
by a suite of post-processing programs that serve both {\tt elegant}
and other physics programs.  These programs, collectively known as the
SDDS Toolkit\cite{SDDS1,SDDS2}, provide sophisticated data analysis
and display capabilities.  They also serve to prepare input for {\tt
elegant}, supporting multi-stage simulation.

Setting up for an {\tt elegant} run thus involves more than creating
input files for {\tt elegant} per se.  A complicated run will
typically involve creation of a post-processing command file that
processes {\tt elegant} output and puts it in the most useful form,
typically a series of graphs.  Users thus have the full power of the
SDDS Toolkit, the resident command interpreter (e.g., the UNIX shell),
and their favorite scripting language (e.g., Tcl/Tk) at their
disposal. The idea is that instead of continually rewriting the
physics code to, for example, make another type of graph or squeeze
another item into a crowded table, one should allow the user to tailor
the output to his specific needs using a set of generic
post-processing programs.  This approach has been quite successful,
and is believed particularly suited to the constantly changing needs
of research.

Unlike many other programs, {\tt elegant} allows one to make a single
run simulating an arbitrary number of randomizations or variations of
an accelerator.  By using the SDDS toolkit to postprocess the data,
the user's postprocessing time and effort do not depend on how many
random seeds or situations are chosen.  Hence, instead of doing a few
simulations with a few seed numbers or values, the user can simulate
hundreds or even thousands of instances of one accelerator to get an
accurate representation of the statistics or dependence on parameters,
with no more work invested than in doing a few simulations.

In addition, complex simulations such as start-to-end jitter
simulations\cite{S2EJitter} and top-up tracking\cite{TopUpTracking}
can be performed involving hundreds or thousands of runs, with input
created by scripts depending on the SDDS toolkit.  These simulations
make use of concurrent computing on about 20 workstation using the
Distributed Queueing System\cite{DQS}.  Another example is the {\tt elegantRingAnalysis} 
script, which allows using many workstations for simulation of storage ring
dynamic and momentum aperture, frequency maps, and so on.
Clearly, use of automated
postprocessing tools greatly increases the scale and sophistication of
simulations possible.  

In passing, we note another ``philosophical'' point about {\tt
elegant}, namely, the goal of complete backward compatibility.  We
consider it unacceptable if a new version of the program gives
different answers than an old version, unless the old version was
wrong.  Hence, there are sometimes less-than-ideal default settings in
{\tt elegant}, incorrect spelling of parameters, etc., that are never
fixed, because doing so would break old input files.  It helps to read
the manual pages carefully for the more complex features to ensure that
the defaults are understood and appropriate.

\subsection{Capabilities of {\tt elegant}}

{\tt elegant} started as a tracking code, and it is still well-suited
to this task.  {\tt elegant} tracks in the 6-dimensional phase space
${\rm (x, x^\prime, y, y^\prime, s, \delta)}$, where $x$ ($y$) is the
horizontal (vertical) transverse coordinate, primed quantities are
slopes, $s$ is the {\em total, equivalent} distance traveled, and $\delta$ is the
fractional momentum deviation\cite{KLBrown}.  Note that these
quantities are commonly referred to as (x, xp, y, yp, s, dp) in the
namelists, accelerator element parameters, and output files.  (``dp''
is admittedly confusing---it is supposed to remind the user of ${\rm
\Delta P/P_o}$.  Sometimes this quantity is referred to as ``delta.'')

Tracking may be performed using matrices (of selectable order),
canonical kick elements, numerically integrated elements, or any
combination thereof.  For most elements, second-order matrices are
available; matrix concatenation can be done to any order up to third.
Canonical kick elements are available for bending magnets,
quadrupoles, sextupoles, and higher-order multipoles; all of these
elements also support optional classical synchrotron radiation losses.
Among the numerically integrated elements available are
extended-fringe-field bending magnets and traveling-wave accelerators.
A number of hybrid elements exist that have first-order transport with
exact time dependence, e.g., RF cavities.    Some of the more unusual
elements available are third-order
alpha-magnets\cite{Enge,Borland_thesis}, time-dependent kicker
magnets, voltage-ramped RF cavities, beam scrapers, and beam-analysis
``screens.''

Several elements support simulation of collective effects, such as
short-range wakefields, resonator impedances, intra-beam scattering,
coherent synchrotron radiation, and the longitudinal space charge
impedance. 

A wide variety of output is available from tracking, including
centroid and sigma-matrix output along the accelerator, phase space
output at arbitrary locations, turn-by-turn moments at arbitrary
locations, histograms of particle coordinates, coordinates of lost
particles, and initial coordinates of transmitted particles.  In
addition to tracking internally generated particle distributions, {\tt
elegant} can track distributions stored in external files, which can
either be generated by other programs or by previous {\tt elegant}
runs.  Because {\tt elegant} uses SDDS format for reading in and
writing out particle coordinates, it is relatively easy to interface
{\tt elegant} to other programs using files that can also be used with
SDDS to do post-processing for the programs.

{\tt elegant} allows the addition of random errors to virtually any
parameter of any accelerator element.  One can correct the orbit (or
trajectory), tunes, and chromaticity after adding errors, then compute
Twiss parameters, track, or perform a number of other operations.
{\tt elegant} makes it easy to evaluate a large number of ensembles (``seeds'')
in a single run.  Alternatively, different ensembles can be readily run
of different CPUs and the SDDS output files combined.

In addition to randomly perturbing accelerator elements, {\tt elegant}
allows one to systematically vary any number of elements in a
multi-dimensional grid.  As before, one can track or do other
computations for each point on the grid.  This is a very useful
feature for the simulation of experiments, e.g., emittance
measurements involving beam-size measurements during variation of one
or more quadrupoles\cite{Borland_PC}.

Like many accelerator codes, {\tt elegant} does accelerator
optimization.  It will optimize a user defined function of the
transfer matrix elements (up to third-order), beta functions, tunes,
chromaticities, radiation integrals, natural emittance, floor
coordinates, beam moments, etc.  It also has the ability to optimize results of
tracking using a user-supplied function of the beam parameters at one
or more locations.  This permits solution of a wide variety of
problems, from matching a kicker bump in the presence of
nonlinearities to optimizing dynamic aperture by adjusting sextupoles.

{\tt elegant} provides several methods for determining accelerator
aperture, whether dynamic or physical.  One may do straightforward
tracking of an ensemble of particles that occupies at uniform grid in
(x, y) space.  One may also invoke a search procedure that finds the
aperture boundary.  A related feature is the ability to determine
the frequency map for an accelerator, to help identify aperture-limiting
resonances.

In addition to using analytical expressions for the transport
matrices, {\tt elegant} supports computation of the first-order matrix
and linear optics properties of a circular machine based on tracking.
A common application of this is to compute the tune and beta-function
variation with momentum offset by single-turn tracking of a series of
particles.  This is much more efficient than, for example, tracking
and performing FFTs (though {\tt elegant} will do this also).  This
both tests analytical expressions for the chromaticity and allows
computations using accelerator elements for which such expressions do
not exist (e.g., a numerically integrated bending magnet with extended
fringe fields).

A common application of random error simulations is to set tolerances
on magnet strength and alignment relative to the correctability of the
closed orbit.  A more efficient way to do these calculations is to use
correct-orbit amplification factors\cite{Borland_PC}.  {\tt elegant}
the computes amplification factors and functions for corrected and
uncorrected orbits and trajectories pertaining to any element that
produces an orbit or trajectory distortion.  It simultaneously
computes the amplification functions for the steering magnets, in
order to determine how strong the steering magnets will need to be.

\section{Digression on the Longitudinal Coordinate Definition\label{sec:longitCoord}}

A word is in order about the definition of $s$, which we've described
as the {\em total, equivalent} distance traveled.  First, by {\em
total} distance we mean that $s$ is {\em not} measured relative to the
bunch center or a fiducial particle.  It is entirely a property of the
individual particle and its path through the accelerator.

To explain what we mean by {\em equivalent} distance, note that the
relationship between $s$ and arrival time $t$ at the observation point
is, for each particle, $s = \beta c t$, where $\beta c$ is the
instantaneous velocity of the particle.  Whenever a particle's
velocity changes, {\tt elegant} recomputes $s$ to ensure that this
relationship holds.  $s$ is thus the ``equivalent'' distance the
particle would have traveled at the present velocity to arrive at the
observation point at the given time.  This book-keeping is required
because {\tt elegant} was originally a matrix-only code using $s$ as
the longitudinal coordinate.

Users should keep the meaning of $s$ in mind when viewing statistics
for $s$, for example, in the {\tt sigma} or watch point output files.
A quantity like {\tt Ss} is literally the rms spread in $s$.  It is
{\em not} defined as $\sigma_t/(\langle \beta \rangle c)$.  A
nonrelativistic beam with velocity spread will show no change in {\tt
Ss} in a drift space, because the distance traveled is the same for
all particles.

\section{Fiducialization in {\tt elegant}}

In some tracking codes, there is a ``fiducial particle'' that is
tracked along with the beam.  This particle follows the ideal trajectory or orbit, with the ideal
momentum, and at the ideal phase.  There is no fiducial particle in {\tt
elegant}.  Instead, fiducialization is typically based on statistical properties of 
the bunch.  This can be performed on a bunch-by-bunch basis, or for the first
bunch seen in a run.  The latter method must be used if one wants to look at the
effects of changing phase, voltage, or magnets relative to some nominal configuration.

Internally, {\tt elegant} fiducializes each element in the beamline.
Fiducializing an element means determining the reference momentum and arrival time
(or phase) for that element.   If the reference momentum does not change along a beamline and no time-dependent elements
are involved, then fiducialization is irrelevant.  All elements are
fiducialized at the central momentum defined in \verb|run_setup|.

A number of commands have parameters for controlling fiducialization:
\begin{itemize}
\item The \verb|always_change_p0| parameter of \verb|run_setup| causes
	\verb|elegant| to re-establish the central momentum after each
	element when fiducializing.  This may be more convenient than
	setting the \verb|CHANGE_P0| parameter on the elements themselves.
	However, it can have unexpected consequences, such as changing the
	central momentum to match changes in beam momentum due to synchrotron
	radiation.
\item \verb|run_control| has three parameters that affect fiducialization,
	which come into play when multi-step runs are made.  Typically, these
	are runs that involve variation of elements, addition of errors,
	or loading of multiple sets of parameters.
	\begin{itemize}
	\item \verb|reset_rf_for_each_step| --- If nonzero, the rf phases are 
	re-established
	for each beam tracked.  If this is 1 (the default), 
	the time reference is discarded after each bunch is tracked.
	This means that bunch-to-bunch phasing errors due to time-of-flight 
	differences would be lost.  
	\item \verb|first_is_fiducial| --- The first bunch seen is taken to
	establish the fiducial phases and momentum profile.  If one is simulating,
	for example, successive beams in a fixed accelerator, this should be set
	to 1.  Otherwise, the momentum reference is discarded after each bunch
	is tracked.
	\item \verb|restrict_fiducialization| --- If nonzero, then momentum profile
	fiducialization occurs only after elements that are known to possibily
	change the momentum. It would not occur, for example, after a scraper that
	changes the average beam momentum by removing a low-momentum tail.
	\end{itemize}
\item The \verb|bunched_beam| command has a \verb|first_is_fiducial| parameter
	that is convenient for use with the \verb|first_is_fiducial| mode
	established by \verb|run_control|.  If nonzero, this parameter causes
	\verb|elegant| to generate a first bunch with only one particle.
	This is very useful if one wants to track with many particles but doesn't
	want to waste time fidicializing with a many-particle bunch.
\end{itemize}

Here are some examples that may be helpful.  
\begin{itemize}
\item {\em Scanning a phase error in a linac with a bunch compressor:}  The scan is performed using
the \verb|vary_element| command.  For this to work properly, it is necessary to fidcualize the system
with zero phase error.  Hence, one must use the enumeration feature of \verb|vary_element| to provide
an input file with the phase errors and the file must be sorted so that the row with zero phase error
is first.  Further, one must set \verb|reset_rf_for_each_step = 0| and \verb|first_is_fiducial = 1|
in \verb|run_control|, and \verb|CHANGE_P0=1| on all rf cavity elements.  (See the \verb|bunchComp/phaseSweep| 
and \verb|bunchComp/dtSweep| examples.)

\item {\em Scanning the voltage of a linac to simulate different operating energy choices at the compressor:}
In this case, one scans the linac voltage, but wants to fiducialize the system for each voltage.
(It's a change in design, not an error or perturbation.)  One again uses \verb|vary_element|, but
nothing special needs to be done about the order of the voltage values.  One must set
\verb|reset_rf_for_each_step = 1| and \verb|first_is_fiducial = 0| in in \verb|run_control|,
and \verb|CHANGE_P0=1| on all rf cavity elements.  (See the \verb|bunchComp/energySweep| example.)

\item {\em Simulation of phase and voltage jitter:}  In this case, one uses the \verb|error_elements|
command to impart errors to the \verb|PHASE| and \verb|VOLT| parameters of rf cavity elements.
However, the first beam through the system must not see any errors.  This is accomplished by
setting \verb|no_errors_for_first_step=1| in \verb|error_control|.  One can also (optionally) use
a 1-particle beam for fiducialization by setting \verb|first_is_fiducial=1| in \verb|bunched_beam|.
In addition, one must set  \verb|reset_rf_for_each_step = 0| and \verb|first_is_fiducial = 1|
in \verb|run_control|, and \verb|CHANGE_P0=1| on all rf cavity elements.  (See the \verb|bunchCompJitter/jitter|
example.)

\end{itemize}

\section{Namelist Command Dictionary}

The main input file for an {\tt elegant} run consists of a series of
namelists, which function as commands.  Most of the namelists direct
{\tt elegant} to set up to run in a certain way.  A few are ``action''
commands that begin the actual simulation.  FORTRAN programmers should
note that, unlike FORTRAN namelists, these namelists need not come in
a predefined order; {\tt elegant} is able to detect which namelist is
next in the file and react appropriately.

\subsection{General Command Syntax}

Each namelist has a number of variables associated with it, which are
used to control details of the run.  These variables come in three
data types: (1) {\tt long}, for the C long integer type.  (2) {\tt
double}, for the C double-precision floating point type. (3) {\tt
STRING}, for a character string enclosed in double quotation marks.
All variables have default values, which are listed on the following
pages.  {\tt STRING} variables often have a default value listed as
{\tt NULL}, which means no data; this is quite different from the
value ``'', which is a zero-length character string.  {\tt long}
variables are often used as logical flags, with a zero value
indicating false and a non-zero value indicating true.

On the following pages the reader will find individual descriptions of each of the namelist commands and their 
variables.  Each description contains a sequence of the form
\begin{verbatim}
&<namelist-name>
    <variable-type> <variable-name> = <default-value>;
    .
    .
    .
&end
\end{verbatim}
This summarizes the parameters of the namelist.  Note, however, that the namelists are invoked in the form
\begin{verbatim}
&<namelist-name>
    [<variable-name> = <value> ,]
    [<array-name>[<index>] = <value> [,<value> ...] ,]
        .
        .
        .
&end
\end{verbatim}  The square-brackets enclose an optional component.  Not all namelists require variables to 
be given--the defaults may be sufficient.  However, if a variable name
is given, it must have a value.  Values for \verb|STRING| variables
must be enclosed in double quotation marks.  Values for \verb|double|
variables may be in floating-point, exponential, or integer format
(exponential format uses the `e' character to introduce the exponent).

Array variables take a list of values, with the first value being
placed in the slot indicated by the subscript.  As in C, the first
slot of the array has subscript 0, {\em not} 1.  The namelist
processor does not check to ensure that one does not put elements into
nonexistent slots beyond the end of the array; doing so may cause the
processor to hang up or crash.

Wildcards are allowed in a number of places in {\tt elegant} and the SDDS Toolkit.  The wildcard format is
very similar to that used in UNIX:
\begin{itemize}
\item \verb|*| --- stands for any number of characters, including none.
\item \verb|?| --- stands for any single character.
\item \verb|[<list-of-characters>]| --- stands for any single character from the list.  The list may include
ranges, such as \verb|a-z|, which includes all characters between and including `a' and `z' in the ASCII
character table.
\end{itemize}
The special characters \verb|*|, \verb|?|, \verb|[|, and \verb|]| are entered literally by preceeding the character by a
backslash (e.g., \verb|\*|).

In many places where a filename is required in an {\tt elegant}
namelist, the user may supply a so-called ``incomplete'' filename.  An
incomplete filename has the sequence ``\%s'' imbedded in it, for which
is substituted the ``rootname.''  The rootname is by default the
filename (less the extension) of the lattice file.  The most common
use of this feature is to cause {\tt elegant} to create names for all
output files that share a common filename but differ in their
extensions.  Post-processing can be greatly simplified by adopting
this naming convention, particularly if one consistently uses the same
extension for the same type of output.  Recommended filename
extensions are given in the lists below.

When {\tt elegant} reads a namelist command, one of its first actions
is to print the namelist back to the standard output.  This printout
includes all the variables in the namelist and their values.
Occasionally, the user may see a variable listed in the printout that
is not in this manual.  These are often obsolete and are retained only
for backward compatibility, or else associated with a feature that is
not fully supported.  Use of such ``undocumented features'' is
discouraged.

{\tt elegant} supports substitution of fields in namelists using the
commandline {\tt macro} option.  This permits making runs with altered
parameters without editing the input file.  Macros inside the input
file have one of two forms: \verb|<tag>| or \verb|\$tag|.  To perform
substitution, use the syntax
\begin{flushleft}{\tt
elegant {\em inputfile} -macro={\em tag1}={\em value1}[,{\em
tag2}={\em value2}...]  }\end{flushleft} When using this feature, it
is important to substitute the value of {\tt rootname} (in run\_setup)
so that one can get a new set of output files (assuming use of the
suggested ``\%s'' field in all the output file names).
One may give the {\tt macro} option any number of times, or combine
all substitutions in one option.  The name of the input file is available
using the macro \verb|INPUTFILENAME|.

{\tt elegant} also allows execution of commands in the shell as part of
evaluation of a namelist field.  To invoke this, one encloses the commandline
string in curly braces.  E.g., 
\begin{verbatim}
betax = "{sdds2stream -parameter=betaxFinal data.twi}"
\end{verbatim}
(Note that the quotes are also required.)
In this example, \verb|betax| is assigned the value of the parameter {\tt betaxFinal} from
the file {\tt data.twi}.
Frequently, the commandline RPN calculator, {\tt rpnl} is also used in this way, for example
\begin{verbatim}
betax = "{rpnl 8 pi / 2 /}"
\end{verbatim}
assigns the value $8/(2 \pi)$ to {\tt betax}. One possible pitfall with using \verb|rpnl| in this
fashion is interpretation of the multiplication symbol (\verb|*|) as a file wildcard by the
shell.  For this reason, the alternate multiplication operator \verb|mult| is preferred, e.g.,
\begin{verbatim}
betax = "{rpnl 8 pi mult}"
\end{verbatim}
rather than
\begin{verbatim}
betax = "{rpnl 8 pi *}"
\end{verbatim}

We used the program {\tt rpnl} in these examples because it is perhaps familiar.  However, versions 17.4 and later
allow direct evaluation of RPN expressions in commands whenever parentheses are used to delimite a sequence.  For example, 
\begin{verbatim}
betax = "(8 2 / pi /)"
\end{verbatim}
(Note that the quotes are also required.)
The advantages of this method are speed (no subprocess is needed),
lack of intermediate interpretation by the shell, and persistence of
the stack and variables.  So, for example, one might use
\begin{verbatim}
betax = "(8 2 / pi / sto betax0)"
betay = "(betax0)"
\end{verbatim}
Another advantage is the ability to mix subcommands and rpn expressions, as in
\begin{verbatim}
betax = "({sdds2stream -parameter=betaxFinal data.twi} 2 /)"
\end{verbatim}
would assign to {\tt betax} half
the value of the parameter {\tt betaxFinal} from
the file {\tt data.twi}.

\subsection{Setup and Action Commands}
 
A subject of frequent confusion for {\tt elegant} users is the
distinction between setup and action commands.  An ``action'' command
causes {\tt elegant} to immediately perform a specific computation or
set of computations.  In contrast, a ``setup'' command tells {\tt elegant}
how to perform computations when it later encounters a ``major'' action
command (one of \verb|analyze_map|, \verb|find_aperture|, \verb|frequency_map|, \verb|momentum_aperture|, \verb|optimize|, 
or \verb|track|).

Several commands are switchable between action and setup modes.  These
include the \verb|coupled_| \verb|twiss_output|,
\verb|correction_matrix_output|, \verb|twiss_output|,
\verb|find_aperture|, \verb|matrix_output|, and \verb|sasefel|
commands.  Except for \verb|find_aperture|, all of the commands that
can run in both modes have the \verb|output_at_each_step| parameter,
which is used to switch between the modes.  In the case of
\verb|find_aperture|, the switch is accomplished using the
\verb|optimization_mode| parameter.  Regardless of which parameter is
present, unless the parameter is given a value of 1, the command
operates in action mode.  Further, if the command is used in setup mode
and no relevant action command is present later in the file, then the requested
will not be performed.

Typically one wants to use these switchable commands in setup mode whenever one is
simulating random errors, performing a parameter scan, or performing optimization.
When in setup mode, the indicated computations will be performed repeatedly, e.g.,
for each set of errors, for each step in the parameter scan, or for use in each
evaluation of the optimization penalty function.

\begin{latexonly}
\newpage
\end{latexonly}
\subsection{Table of {\tt elegant} commands and their functions}

\begin{longtable}{|p{2.75in}|p{0.75in}|p{2.75in}|}
\hline
Command name & Type & Description \\\hline 
\hyperref{{\tt alter\_elements}}{{\tt alter\_elements}}{}{subsec:alterelements} & action & Change an element parameter from the command file. \\ \hline
\hyperref{{\tt amplification\_factors}}{{\tt amplification\_factors}}{}{subsec:amplificationfactors} & action & Compute orbit amplification functions. \\ \hline
\hyperref{{\tt analyze\_map}}{{\tt analyze\_map}}{}{subsec:analyzemap} & major action & Determine first-order matrix from tracking. \\ \hline
\hyperref{{\tt aperture\_data}}{{\tt aperture\_data}}{}{subsec:aperturedata} & setup & Define aperture using an SDDS file. \\ \hline
\hyperref{{\tt bunched\_beam}}{{\tt bunched\_beam}}{}{subsec:bunchedbeam} & setup & Set up beam generation. \\ \hline
\hyperref{{\tt change\_particle}}{{\tt change\_particle}}{}{subsec:changeparticle} & action & Change the type of particle. Default is electron.\\ \hline
\hyperref{{\tt chromaticity}}{{\tt chromaticity}}{}{subsec:chromaticity} & setup & Correct the chromaticity. \\ \hline
\hyperref{{\tt closed\_orbit}}{{\tt closed\_orbit}}{}{subsec:closedorbit} & setup & Compute the closed orbit. \\ \hline
\hyperref{{\tt correct}}{{\tt correct}}{}{subsec:correct} & setup & Correct the orbit or trajectory. \\ \hline
\hyperref{{\tt correction\_matrix\_output}}{{\tt correction\_matrix\_output}}{}{subsec:correctionmatrixoutput} & action/setup & Obtain orbit/trajectory correction matrix in a file. \\ \hline
\hyperref{{\tt correct\_tunes}}{{\tt correct\_tunes}}{}{subsec:correcttunes} & setup & Correct the tunes. \\ \hline
\hyperref{{\tt coupled\_twiss\_output}}{{\tt coupled\_twiss\_output}}{}{subsec:coupledtwissoutput} & setup/action & Compute and output coupled twiss parameters. \\ \hline
\hyperref{{\tt divide\_elements}}{{\tt divide\_elements}}{}{subsec:divideelements} & setup & Specify division of elements into pieces. \\ \hline
\hyperref{{\tt error\_element}}{{\tt error\_element}}{}{subsec:errorelement} & setup & Define errors for a set of elements. \\ \hline
\hyperref{{\tt error\_control}}{{\tt error\_control}}{}{subsec:errorcontrol} & setup & Set up and control error generation process. \\ \hline
\hyperref{{\tt find\_aperture}}{{\tt find\_aperture}}{}{subsec:findaperture} & setup/major action & Determine the transverse (e.g., dynamic) aperture. \\ \hline
\hyperref{{\tt floor\_coordinates}}{{\tt floor\_coordinates}}{}{subsec:floorcoordinates} & action & Compute and output floor coordinates. \\ \hline
\hyperref{{\tt frequency\_map}}{{\tt frequency\_map}}{}{subsec:frequencymap} & major action & Compute and output frequency map. \\ \hline
\hyperref{{\tt global\_settings}}{{\tt global\_settings}}{}{subsec:globalsettings} & action & Change global settings.\\ \hline
\hyperref{{\tt insert\_elements}}{{\tt insert\_sceffects}}{}{subsec:insertelements} & action & Insert elements into the lattice at many places. \\ \hline
\hyperref{{\tt insert\_sceffects}}{{\tt insert\_sceffects}}{}{subsec:insertsceffects} & action & Insert space charge kick elements. \\ \hline
\hyperref{{\tt linear\_chromatic\_tracking\_setup}}{{\tt linear\_chromatic\_tracking\_setup}}{}{subsec:linearchromatictrackingsetup} & setup & Set up for fast tracking with chromatic effects. \\ \hline
\hyperref{{\tt link\_control}}{{\tt link\_control}}{}{subsec:linkcontrol} & setup & Control linking of element parameters. \\ \hline
\hyperref{{\tt link\_elements}}{{\tt link\_elements}}{}{subsec:linkelements} & setup & Define link between parameters of two elements. \\ \hline
\hyperref{{\tt load\_parameters}}{{\tt load\_parameters}}{}{subsec:loadparameters} & setup/action & Load element parameters from SDDS file. \\ \hline
\hyperref{{\tt matrix\_output}}{{\tt matrix\_output}}{}{subsec:matrixoutput} & setup/action & Output transfer matrix along beamline. \\ \hline
\hyperref{{\tt modulate\_elements}}{{\tt modulate\_elements}}{}{subsec:modulateelements} & setup & Set up time-dependent modulation of elements. \\ \hline

\hyperref{{\tt moments\_output}}{{\tt moments\_output}}{}{subsec:momentsoutput} & setup/action & Compute coupled beam moments, with radiation option. \\ \hline
\hyperref{{\tt momentum\_aperture}}{{\tt momentum\_aperture}}{}{subsec:momentumaperture} & major action & Determine s-dependent momentum aperture. \\ \hline
\hyperref{{\tt optimize}}{{\tt optimize}}{}{subsec:optimize} & major action & Execute an optimization. \\ \hline
\hyperref{{\tt optimization\_covariable}}{{\tt optimization\_covariable}}{}{subsec:optimizationcovariable} & setup & Define a dependent parameter for optimization. \\ \hline
\hyperref{{\tt optimization\_setup}}{{\tt optimization\_setup}}{}{subsec:optimizationsetup} & setup & Perform initial optimization setup. \\ \hline
\hyperref{{\tt optimization\_term}}{{\tt optimization\_term}}{}{subsec:optimizationterm} & setup & Define a term of penalty function. \\ \hline
\hyperref{{\tt optimization\_variable}}{{\tt optimization\_variable}}{}{subsec:optimizationvariable} & setup & Define an optimization variable. \\ \hline
\hyperref{{\tt parallel\_optimization\_setup}}{{\tt parallel\_optimization\_setup}}{}{subsec:paralleloptimizationsetup} & setup & Perform initial parallel optimization setup. \\ \hline
\hyperref{{\tt print\_dictionary}}{{\tt print\_dictionary}}{}{subsec:printdictionary} & action & Print the element dictionary. \\ \hline
\hyperref{{\tt ramp\_elements}}{{\tt ramp\_elements}}{}{subsec:rampelements} & setup & Set up turn-by-turn ramping of elements. \\ \hline
\hyperref{{\tt rpn\_expression}}{{\tt rpn\_expression}}{}{subsec:rpnexpression} & action & Execute an expression in the rpn interpreter. \\ \hline
\hyperref{{\tt rpn\_load}}{{\tt rpn\_load}}{}{subsec:rpnload} & action & Load values from SDDS file into rpn interpreter. \\ \hline
\hyperref{{\tt run\_control}}{{\tt run\_control}}{}{subsec:runcontrol} & setup & Set up simulation steps and passes. \\ \hline
\hyperref{{\tt run\_setup}}{{\tt run\_setup}}{}{subsec:runsetup} & setup & Define global simulation parameters and output files. \\ \hline
\hyperref{{\tt sasefel}}{{\tt sasefel}}{}{subsec:sasefel} & setup/action & Evaluate SASE FEL gain etc. \\ \hline
\hyperref{{\tt save\_lattice}}{{\tt save\_lattice}}{}{subsec:savelattice} & action & Save new lattice file. \\ \hline
\hyperref{{\tt sdds\_beam}}{{\tt sdds\_beam}}{}{subsec:sddsbeam} & setup & Define loading of particles from SDDS file. \\ \hline
\hyperref{{\tt semaphores}}{{\tt semaphores}}{}{subsec:semaphores} & setup & Define file semaphores for start/end of run. \\ \hline
\hyperref{{\tt slice\_analysis}}{{\tt slice\_analysis}}{}{subsec:sliceanalysis} & setup & Perform slice analysis along beamline. \\ \hline
\hyperref{{\tt subprocess}}{{\tt subprocess}}{}{subsec:subprocess} & action & Execute a command in the shell. \\ \hline
\hyperref{{\tt steering\_element}}{{\tt steering\_element}}{}{subsec:steeringelement} & setup & Define element parameters as steering correctors. \\ \hline
\hyperref{{\tt transmute\_elements}}{{\tt transmute\_elements}}{}{subsec:transmuteelements} & setup & Transmute elements from one type to another. \\ \hline
\hyperref{{\tt twiss\_analysis}}{{\tt twiss\_analysis}}{}{subsec:twissanalysis} & setup & Define subset of beamline for twiss parameter analysis. \\ \hline
\hyperref{{\tt twiss\_output}}{{\tt twiss\_output}}{}{subsec:twissoutput} & setup/action & Set up twiss parameter and related computation. \\ \hline
\hyperref{{\tt track}}{{\tt track}}{}{subsec:track} & major action & Execute tracking of particles and other operations. \\ \hline
\hyperref{{\tt tune\_shift\_with\_amplitude}}{{\tt tune\_shift\_with\_amplitude}}{}{subsec:tuneshiftwithamplitude} & setup & Compute tune shifts with amplitude. \\ \hline
\hyperref{{\tt vary\_element}}{{\tt vary\_element}}{}{subsec:varyelement} & setup & Vary element parameters in loops. \\ \hline
%\end{tabular}
%\end{center}
\caption{Table of {\tt elegant} commands and their functions.}
\end{longtable}

\clearpage

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|alter_elements|}\end{center}
\end{latexonly}
\subsection{alter\_elements\label{subsec:alterelements}}

\begin{itemize}
\item type: action command.
\item function: modify the value of a parameter for one or more elements
\end{itemize}

\begin{verbatim}
&alter_elements
        STRING name = NULL;
        STRING item = NULL;
        STRING type = NULL;
        STRING exclude = NULL;
        double value = 0;
        STRING string_value = NULL;
        long differential = 0;
        long multiplicative = 0;
        long verbose = 0;
        long allow_missing_elements = 0;
        long allow_missing_parameters = 0;
        long start_occurence = 0;
        long end_occurence = 0;
        double s_start = -1;
        double s_end = -1;
        STRING before = NULL;
        STRING after = NULL;
&end
\end{verbatim}

\begin{itemize}
\item \verb|name| --- A possibly-wildcard-containing string giving the names of the
        elements to alter.  If not specified, then one must specify \verb|type|.
\item \verb|item| --- The name of the parameter to alter.
\item \verb|type| --- A possibly-wildcard-containing string giving the names of element
        {\em types} to alter.  May be specified with \verb|name| or by itself.
\item \verb|exclude| --- A possibly-wildcard-containing string giving the names of elements
        to excluded from alteration.
\item \verb|value|, \verb|string_value| --- The new value for the parameter.  Use
      \verb|string_value| only if the parameter takes a character string as its value.
\item \verb|differential| --- If nonzero, the new value is 
        the predefined value of the parameter plus the quantity given with \verb|value|.
\item \verb|multiplicative| --- If nonozero, the new given value is the predefined
        value of the parameter times the quantity given with \verb|value|.
\item \verb|verbose| --- If nonzero, information is printed to the standard output describing
        what elements are changed.
\item \verb|allow_missing_elements| --- If nonzero, then it is not an error if an
        element matching \verb|name| does not exist.   Normally, such
        an occurence is an error and terminates the program.
\item \verb|allow_missing_parameters| --- If nonzero, then it is not an error if an
        element does not have the parameter named with \verb|item|.  Normally, such
        an occurence is an error and terminates the program.
\item \verb|start_occurence|, \verb|end_occurence| --- If nonzero, these give the starting and
 ending occurence numbers of elements that will be altered.  N.B.: if wildcards are used, occurence
 number counting is for each set of identically-named elements separately, rather than for the sequence
 of matched elements.
\item \verb|s_start|, \verb|s_end| --- If non-negative, these give the gaving and ending position
 limits for the end-of-element locations of elements to be altered.
\item \verb|after| --- The name of an element.  If given, the alteration is applied only to elements
 that follow the named element in the beamline.  
\item \verb|before| --- The name of an element.  If given, the alteration is applied only to elements
 that precede the named element in the beamline. 
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|amplification_factors|}\end{center}
\end{latexonly}
\subsection{amplification\_factors \label{subsec:amplificationfactors}}

\begin{itemize}
\item type: action command.
\item function: compute corrected and uncorrected orbit amplification factors and functions.
\end{itemize}

\begin{verbatim}
&amplification_factors
    STRING output = NULL;
    STRING uncorrected_orbit_function = NULL;
    STRING corrected_orbit_function = NULL;
    STRING kick_function = NULL;
    STRING name = NULL;
    STRING type = NULL;
    STRING item = NULL;
    STRING plane = NULL;
    double change = 1e-3;
    long number_to_do = -1;
    double maximum_z = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|output| ---  The (incomplete) name of a file for text output.   Recommended value: ``\%s.af''.
\item \verb|uncorrected_orbit_function| --- The (incomplete) name of a file for an SDDS-format output of the
    uncorrected-orbit amplification function.  Recommended value: ``\%s.uof''.
\item \verb|corrected_orbit_function| --- The (incomplete) name of a file for an SDDS-format output of the
    corrected-orbit amplification function.  Recommended value: ``\%s.cof''.
\item \verb|kick_function| --- The (incomplete) name of a file for an SDDS-format output of the kick amplification function.
Recommended value: ``\%s.kaf''.
\item \verb|name| --- The optionally wildcarded name of the orbit-perturbing elements.  
\item \verb|type| --- The optional type name of the the orbit-perturbing elements.
\item \verb|item| --- The parameter of the elements producing the orbit.
\item \verb|plane| --- The plane (``h'' or ``v'') to examine.
\item \verb|change| --- The parameter change to use in computing the amplification.  
\item \verb|number_to_do| --- The number of elements to perturb.
\item \verb|maximum_z| --- The maximum z coordinate of the elements to perturb.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|analyze_map|}\end{center}
\end{latexonly}
\subsection{analyze\_map \label{subsec:analyzemap}}

\begin{itemize}
\item type: major action command.
\item function: find the approximate first-order matrix and related quantities for an accelerator by tracking.
\end{itemize}

\begin{verbatim}
&analyze_map
    STRING output = NULL;
    double delta_x = 1e-6;
    double delta_xp = 1e-6;
    double delta_y = 1e-6;
    double delta_yp = 1e-6;
    double delta_s  = 1e-6;
    double delta_dp = 1e-6;
    long center_on_orbit = 0;
    long verbosity = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|output| --- The (incomplete) name of a file for SDDS output.
    \begin{itemize}
    \item Recommended value: ``\%s.ana''.
    \item File contents:  A series of dumps, each consisting of a single data point containing
        the centroid offsets for a single turn, the single-turn R matrix, the matched Twiss parameters, tunes, and 
        dispersion functions.
    \end{itemize}
\item \verb|delta_X| --- The amount by which to change the quantity X in computing the derivatives that give the matrix elements.
\item \verb|center_on_orbit| --- A flag directing the expansion to be made about the closed orbit instead of the design orbit.
\item \verb|verbosity| --- The larger this value, the more output is printed during computations.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|aperture_data|}\end{center}
\end{latexonly}
\subsection{aperture\_data \label{subsec:aperturedata}}

\begin{itemize}
\item type: setup command.
\item function: specify a file from which to take x and y aperture data vs s.
\item note: this command is also available under the name \verb|aperture_input|.
\end{itemize}

\begin{verbatim}
&aperture_data
        STRING input = NULL;
        long periodic = 1; 
        long persistent = 0;
        long disable = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|input| --- Name of SDDS file supplying the aperture data.  The following columns are
  all required, in double or float type, with units of \verb|m| (meters).
  \begin{enumerate}
    \item \verb|s| --- Distance along the central trajectory.  
    \item \verb|xHalfAperture| --- Half aperture in the horizontal. 
    \item \verb|yHalfAperture| --- Half aperture in the vertical.
    \item \verb|xCenter| --- Center of the aperture in the horizontal.
    \item \verb|yCenter| --- Center of the aperture in the vertical.
  \end{enumerate}
\item \verb|periodic| --- If non-zero, the aperture is a periodic function of \verb|s|, with period equal
  to the range of the data.
\item \verb|persistent| --- If non-zero, the aperture data persists across subsequent \verb|run_setup| commands.
  By default, the aperture data is forgotten when a new \verb|run_setup| command is seen.
\item \verb|disable| --- If non-zero, the command is ignored.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|bunched_beam|}\end{center}
\end{latexonly}
\subsection{bunched\_beam \label{subsec:bunchedbeam}}

\begin{itemize}
\item type: setup command.
\item function: set up for tracking of particle coordinates with various distributions.
\end{itemize}

\begin{verbatim}
&bunched_beam
    STRING bunch = NULL;
    long n_particles_per_bunch = 1;
    double time_start = 0;
    STRING matched_to_cell = NULL;
    double emit_x  = 0;
    double emit_nx  = 0;
    double beta_x  = 1.0;
    double alpha_x = 0.0;
    double eta_x   = 0.0;
    double etap_x  = 0.0;
    double emit_y  = 0;
    double emit_ny  = 0;
    double beta_y  = 1.0;
    double alpha_y = 0.0;
    double eta_y   = 0.0;
    double etap_y  = 0.0;
    long use_twiss_command_values = 0;
    double Po = 0.0;
    double sigma_dp = 0.0;
    double sigma_s = 0.0;
    double dp_s_coupling = 0;
    double emit_z = 0;
    double beta_z = 0;
    double alpha_z = 0;
    double momentum_chirp = 0;
    long one_random_bunch = 1;
    long symmetrize = 0;
    long halton_sequence[3] = {0, 0, 0};
    long halton_radix[6] = {0, 0, 0, 0, 0, 0};
    long optimized_halton = 0;
    long randomize_order[3] = {0, 0, 0};
    long limit_invariants = 0;
    long limit_in_4d = 0;
    long enforce_rms_values[3] = {0, 0, 0};
    double distribution_cutoff[3] = {2, 2, 2};
    STRING distribution_type[3] = {"gaussian","gaussian","gaussian"};
    double centroid[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
    long first_is_fiducial = 0;
    long save_initial_coordinates = 1;
&end
\end{verbatim}

\begin{itemize}
\item \verb|bunch| --- The (incomplete) name of an SDDS file to which the phase-space coordinates
of the bunches are to be written.  Recommended value: ``\%s.bun''.  
\item \verb|n_particles_per_bunch| --- Number of particles in each bunch.
\item \verb|time_start| --- The central value of the time coordinate for the bunch.
\item \verb|matched_to_cell| --- The name of a beamline from which the Twiss parameters of the bunch
are to be computed.
\item \verb|emit_X| --- RMS emittance for the X plane.
\item \verb|emit_nX| --- RMS normalized emittance for the X plane.  Ignored if \verb|emit_X| is nonzero.
\item \verb|beta_X|, \verb|alpha_X|, \verb|eta_X|, \verb|etap_X| --- Twiss parameters for the X plane.
\item \verb|use_twiss_command_values| --- If nonzero, then the values for $\beta$, $\alpha$, 
        $\eta$, and $\eta^\prime$ are taken from the \verb|twiss_output| command.  It is an error if
        no \verb|twiss_output| command has been given.
\item \verb|Po| --- Central momentum of the bunch.
\item \verb|sigma_dp|, \verb|sigma_s| --- Fractional momentum spread, ${\rm \delta}$, and bunch length.
Note that \verb|sigma_s| is actually the length in $\beta_z*c*t$, so that for $\beta_z<<1$ the length of
the bunch in time will be greater than one might expect.
\item \verb|dp_s_coupling| ---  Specifies the coupling between s and ${\rm \delta}$, defined as 
${\rm \langle s \delta \rangle/(\sigma_s\sigma_\delta)}$.
\item \verb|emit_z|, \verb|beta_z|, \verb|alpha_z| --- Provide another way to specify the
 longitudinal phase space, either separately from or in combination with 
 \verb|sigma_dp|, \verb|sigma_s|, and \verb|dp_s_coupling|.  

Basically, which values {\tt elegant} uses depends on what one sets to
nonzero values.  If one sets emit\_z, then sigma\_dp, sigma\_s, and
dp\_s\_coupling are ignored.  If one doesn't set emit\_z, then {\tt
elegant} uses sigma\_dp and sigma\_s; it additionally uses alpha\_z if
it is nonzero, otherwise it uses dp\_s\_coupling.  For reference, the
relationship between them is $ C =
\frac{\Sigma_{56}}{\sqrt{\Sigma_{55}\Sigma_{66}}} =
-\frac{\alpha}{\sqrt{1+\alpha^2}}$.  Note that to impart a chirp that
results in compression for $R_{56}<0$ (e.g., a normal four-dipole
chicane), one must have $\alpha_z<0$ or $C>0$.

\item \verb|momentum_chirp| --- Permits imparting an additional
momentum chirp to the beam, in units of 1/m.  E.g., a value of 1
indicates that a 1mm long bunch has a linear variation in momentum of
0.1\% from end-to-end.  A positive chirp is needed to provide
compression of a bunch with an ordinary $R_{56}<0$ four-dipole
chicane.

\item \verb|one_random_bunch| --- If non-zero, then only one random
particle distribution is generated.  Otherwise, a new distribution
will be generated for every simulation step.

\item \verb|enforce_rms_values[3]| --- Flags, one for each plane,
indicating whether to force the distribution to have the specified RMS
properties.

\item \verb|distribution_cutoff[3]| --- Distribution cutoff parameters
for each plane.  For gaussian distributions, this is the number of
sigmas to use.  For other distributions (except dynamic aperture),
this number simply multiplies the sizes.  This is potentially
confusing and hence it is suggested that the distribution cutoff be
set to 1 for nongaussian beams.

The exception is ``dynamic-aperture'' distribution type.  In this case,
the cutoff value is the number of grid points in the dimension in question.

\item \verb|distribution_type[3]| --- Distribution type for each
plane.  May be ``gaussian'', ``hard-edge'', ``uniform-ellipse'',
``shell'', ``dynamic-aperture'', ``line'', ``halo(gaussian)''.

For the transverse plane, the interpretation of the emittance is
different for the different beam types.  For gaussian beams, the
emittances are rms values.  For all other types, $\sqrt{\epsilon*\beta}$
times the distribution cutoff defines the edge of the beam in position
space, while $\sqrt{\epsilon*(1+\alpha^2)/\beta}$ times the distribution
cutoff defines the edge of the beam in slope space.  

A hard-edge beam is a uniformly-filled parallelogram in phase space.
A uniform-ellipse beam is a uniformly-filled ellipse in phase space.
A shell beam is a hollow ellipse in phase space.  A dynamic aperture
beam has zero slope and uniform spacing in position coordinates.  A
line beam is a line in phase space.  A ``halo(gaussian)'' beam is
the part of the gaussian distribution {\em beyond} the distribution cutoff.

\item \verb|limit_invariants| --- If non-zero, the distribution
cutoffs are applied to the invariants, rather than to the coordinates.
This is useful for gaussian beams when the distribution cutoff is
small.

\item \verb|limit_in_4d| --- If non-zero, then the transverse
distribution is taken to be a 4-d gaussian or uniform distribution.
One of these must be chosen using the \verb|distribution_type|
control.  It must be the same for x and y.  This is useful, for
example, if you want to make a cylindrically symmetric beam.

\item \verb|symmetrize| --- If non-zero, the distribution is symmetric
under changes of sign in the coordinates.  Automatically results in a
zero centroid for all coordinates.

\item \verb|halton_sequence[3]| and \verb|halton_radix[6]| and \verb|optimized_halton|
--- This provides a ``quiet-start'' feature by choosing Halton sequences in
place of random number generation.  There are three new variables that
control this feature.  \verb|halton_sequence| is an array of three
flags that permit turning on Halton sequence generation for the
horizontal, vertical, or longitudinal planes.  For example,
\verb|halton_sequence[0] = 3*1| will turn on Halton sequences for all
three planes, while \verb|halton_sequence[2] = 1|, will turn it on for
the longitudinal plane only.

\verb|halton_radix| is an array of six integers that permit giving the
radix for each sequence (i.e., x, x', y, y', t, p).  Each radix must
be a prime number.  One should never use the same prime for two
sequences, unless one randomizes the order of the sequences relative to
each other (see the next item).  If these are left at zero, then
elegant chooses values that eliminate phase-space banding to some
extent.  The user is cautioned to plot all coordinate combinations for
the initial phase space to ensure that no unacceptable banding is
present.

A suggested way to use Halton sequences is to set
\verb|halton_radix[0] = 2, 3, 2, 3, 2, 3| and
to set 
\verb|randomize_order[0] = 2, 2, 2,|.  This avoids banding that may
result from choosing larger radix values.

\verb|optimized_halton| uses the improved halton sequence \cite{Chi2005}.
(Algorithm 659, Collected Algorithm from ACM. Derandom Algorithm is added
by Hongmei CHI (CS/FSU)). It avoids the banding problem automatically and
the \verb|halton_radix| values are ignored.

\item \verb|randomize_order[3]| --- Allows randomizing the order of
assigned coordinates for the pairs (x, x'), (y, y'), and (t,p).  0
means no randomization; 1 means randomize (x, x', y, y', t, p) values
independently, which destroys any x-x', y-y', and t-p correlations; 2
means randomize (x, x'), (y, y'), and (t, p) in pair-wise fashion.
This is used with Halton sequences to remove banding.  It is suggested
that that the user employ \verb|sddsanalyzebeam| to verify that the
beam properties when randomization is used.

\item \verb|centroid[6]| --- Centroid offsets for each of the six coordinates.

\item \verb|first_is_fiducial| --- Specifies that the first beam
generated shall be a single particle beam, which is suitable for
fiducialization.  See the section on ``Fiducialization in
\verb|elegant|'' for more discussion.

\item \verb|save_initial_coordinates| --- A flag that, if set, results
in saving initial coordinates of tracked particles in memory.  This is
the default behavior.  If unset, the initial coordinates are not
saved, but are regenerated each time they are needed.  This is more
memory efficient and is useful for tracking very large numbers of
particles.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|change_particle|}\end{center}
\end{latexonly}
\subsection{change\_particle\label{subsec:changeparticle}}

\begin{itemize}
\item type: action command.
\item function: change the particle type from the default value of ``electron.''
\item N.B.: this feature has had limited testing, mostly to verify that electron tracking is not
 impacted by the implementation.  Please use with caution and be alert for suspicious results.
\end{itemize}

\begin{verbatim}
&change_particle
    STRING name = "electron";
    double mass_ratio = 0;
    double charge_ratio = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|name| --- The name of the particle to use.  Possible values are \verb|electron|, \verb|positron|,
  \verb|proton|, \verb|muon|, and \verb|custom|.
\item \verb|mass_ratio|, \verb|charge_ratio| --- If the particle name is ``custom,'' these parameters specify the
  mass and charge of the particle relative to the electron.  E.g., for an anti-proton, one would use
  a mass ratio of 1836.18 and a charge ratio of 1.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|chromaticity|}\end{center}
\end{latexonly}
\subsection{chromaticity \label{subsec:chromaticity}}

\begin{itemize}
\item type: setup command.
\item function: set up for chromaticity correction.
\end{itemize}

\begin{verbatim}
&chromaticity
    STRING sextupoles = NULL;
    double dnux_dp = 0;
    double dnuy_dp = 0;
    double sextupole_tweek = 1e-3;
    double correction_fraction = 0.9;
    long n_iterations = 5;
    double tolerance = 0;
    STRING strength_log = NULL;
    long change_defined_values = 0;
    double strength_limit = 0;
    long use_perturbed_matrix = 0;    
&end
\end{verbatim}

\begin{itemize}
\item \verb|sextupoles| --- List of names of elements to use to correct the chromaticities.
\item \verb|dnux_dp|, \verb|dnuy_dp| --- Desired chromaticity values.
\item \verb|sextupole_tweek| --- Amount by which to tweak the sextupoles to compute derivatives of
chromaticities with respect to sextupole strength.  [The word ``tweak'' is misspelled ``tweek'' in the code.]
\item \verb|correction_fraction| --- Fraction of the correction to apply at each iteration.  In some
cases, correction is unstable at this number should be reduced.
\item \verb|n_iterations| --- Number of iterations of the correction to perform.
\item \verb|tolerance| --- Stop iterating when chromaticities are within this value of the
desired values.
\item \verb|strength_log| --- The (incomplete) name of an SDDS file to which the sextupole strengths will
be written.  Recommended value: ``\%s.ssl''.
\item \verb|change_defined_values| --- Changes the defined values of the sextupole strengths.
This means that when the lattice is saved (using \verb|save_lattice|), the sextupoles will
have the corrected values.  This would be used for correcting the chromaticity of a design
lattice, for example, but not for correcting chromaticity of a perturbed lattice.
\item \verb|strength_limit| --- Limit on the absolute value of sextupole strength ($K_2$).
`\item \verb|use_perturbed_matrix| --- If nonzero, requests use of the perturbed correction matrix in
performing correction.  For difficult lattices with large errors, this may be necessary
to obtain correction.  In general, it is not necessary and only slows the simulation.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|closed_orbit|}\end{center}
\end{latexonly}
\subsection{closed\_orbit \label{subsec:closedorbit}}

\begin{itemize}
\item type: setup command.
\item function: set up for computation of the closed orbit.
\end{itemize}

\begin{verbatim}
&closed_orbit
    STRING output = NULL;
    long output_monitors_only = 0;
    long start_from_centroid = 1;
    long start_from_dp_centroid = 1;
    double closed_orbit_accuracy = 1e-12;
    long closed_orbit_iterations = 10;
    double iteration_fraction = 1;
    long fixed_length = 0;
    long start_from_recirc = 0;
    long verbosity = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|output| --- The (incomplete) name of an SDDS file to which
the closed orbits will be written.  Recommended value: ``\%s.clo''.
\item \verb|output_monitors_only| --- If non-zero, indicates that the
closed orbit output should include only the data at the locations of
the beam-position monitors.
\item \verb|start_from_centroid| --- A flag indicating whether to
force the computation to start from the centroids of the beam
distribution.
\item \verb|start_from_dp_centroid| --- A flag indicating whether to 
force the computation to use the momentum centroid of the beam 
for the closed orbit.  This can allow computing the closed orbit
for an off-momentum beam, then starting the beam on that orbit
using the \verb|offset_by_orbit| or \verb|center_on_orbit| parameters
of the \verb|track| command.  In contrast to the \verb|start_from_centroid|,
this command doesn't force the algorithm to start from the beam
transverse centroids.
\item \verb|closed_orbit_accuracy| --- The desired accuracy of the
closed orbit, in terms of the difference between the start and end
coordinates, in meters.
\item \verb|closed_orbit_iterations| --- The number of iterations to
take in finding the closed orbit.
\item \verb|iteration_fraction| --- Fraction of computed change that
is used each iteration.  For lattices that are very nonlinear or close
to unstable, a number less than 1 can be helpful.  Otherwise, it only
slows the simulation.
\item \verb|fixed_length| --- A flag indicating whether to find a
closed orbit with the same length as the design orbit by changing the
momentum offset.
\item \verb|start_from_recirc| --- A flag indicating whether to
compute the closed orbit from the recirculation (\verb|recirc|)
element in the beamline.  In general, if one has a recirculation
element, one should give this flag.
\item \verb|verbosity| --- A larger value results in more printouts
during the computations.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|correct|}\end{center}
\end{latexonly}
\subsection{correct \label{subsec:correct}}

\begin{itemize}
\item type: setup command.
\item function: set up for correction of the trajectory or closed orbit.
\end{itemize}

\begin{verbatim}
&correct
    STRING mode = "trajectory";
    STRING method = "global";
    STRING trajectory_output = NULL;
    STRING corrector_output = NULL;
    STRING statistics = NULL;
    double corrector_tweek[2] = {1e-3, 1e-3};
    double corrector_limit[2] = {0, 0};
    double correction_fraction[2] = {1, 1};
    double correction_accuracy[2] = {1e-6, 1e-6};
    long remove_smallest_SVs[2] = {0, 0};
    long keep_largest_SVs[2] = {0, 0};
    double minimum_SV_ratio[2] = {0, 0};
    long auto_limit_SVs[2] = {1, 1};
    long threading_divisor[2] = {100, 100};
    double bpm_noise[2] = {0, 0};
    double bpm_noise_cutoff[2] = {1.0, 1.0};
    STRING bpm_noise_distribution[2] = {"uniform", "uniform"};
    long verbose = 1;
    long fixed_length = 0;
    long fixed_length_matrix = 0;
    long n_xy_cycles = 1;
    long minimum_cycles = 1;
    long n_iterations = 1;
    long prezero_correctors = 1;
    long track_before_and_after = 0;
    long start_from_centroid = 1;
    long use_actual_beam = 0;
    double closed_orbit_accuracy = 1e-12;
    long closed_orbit_iterations = 10;
    double closed_orbit_iteration_fraction = 1;
    long use_perturbed_matrix = 0;
&end
\end{verbatim}

In the case of array variables with dimension 2, the first entry is for the horizontal plane and the second
is for the vertical plane.

\begin{itemize}

\item \verb|mode| --- Either ``trajectory'' or ``orbit'', indicating
correction of a trajectory or a closed orbit.
\item \verb|method| --- For trajectories, may be ``one-to-one'', ``one-to-best'', ``one-to-next'', ``thread'', or ``global''.  
``One-to-one'' and ``one-to-next'' are the same: steering is performed by pairing one corrector with the next downstream BPM.
``One-to-best'' attempts to find a BPM with a large response to each corrector.  ``Thread'' does corrector sweeps to work the
beam through a beamline with apertures; it is quite slow.  ``Global'' simply uses the global response matrix; it is the best
choice if the trajectory is not lost on an aperture.
For closed orbit, must be ``global''.
\item \verb|trajectory_output| --- The (incomplete) name of an SDDS file to which the trajectories or orbits will be written.  Recommended value: ``\%s.traj'' or ``\%s.orb''.  
\item \verb|corrector_output| --- The (incomplete) name of an SDDS file to which information about the final corrector strengths will be written. Recommended value: ``\%s.cor''.  
\item \verb|statistics| --- The (incomplete) name of an SDDS file to which statistical information about the
trajectories (or orbits) and corrector strengths will be written.  Recommended value: ``\%s.scor''.
\item \verb|corrector_tweek[2]| --- The amount by which to change the correctors in order to compute correction coefficients for
transport lines.
[The word ``tweak'' is misspelled ``tweek'' in the code.]   The default value, 1 mrad, may be too large for systems with
small apertures.  If you get an error message about ``tracking failed for test particle,'' try decreasing this value.
\item \verb|corrector_limit[2]| --- The maximum strength allowed for a corrector.
\item \verb|correction_fraction[2]| --- The fraction of the computed correction strength to actually use for any one iteration.
\item \verb|correction_accuracy[2]| --- The desired accuracy of the correction in terms of the RMS BPM values.
\item \verb|remove_smallest_SVs|, \verb|keep_largest_SVs|, \verb|minimum_SV_ratio|, \verb|auto_limit_SVs| --- These parameters control the elimination of
  singular vectors from the inverse response matrix, which can help deal with degeneracy in the correctors and reduce corrector strength.
  By default, the number of singular vectors is limited to the number of BPMs, which is a basic condition for stability; this can be defeated by
  setting \verb|auto_limit_SVs| to 0 for the desired planes.  Set \verb|remove_smallest_SVs| to require removal of a given number of
  vectors with the smallest singular values; this is ignored if \verb|auto_limit_SVs| is also requested and would remove more SVs. 
  Set \verb|keep_largest_SVs| to require keeping at most a given number of the largest SVs.
  Set \verb|minimum_SV_ratio| to require removal of any vectors with singular values less than a given factor of the largest singular value.
\item \verb|bpm_noise[2]| --- The BPM noise level. 
\item \verb|bpm_noise_cutoff[2]| --- Cutoff values for the random distributions of BPM noise.
\item \verb|bpm_noise_distribution[2]| --- May be either ``gaussian'', ``uniform'', or ``plus\_or\_minus''.
\item \verb|verbose| --- If non-zero, information about the correction is printed during computations.
\item \verb|fixed_length| --- Indicates that the closed orbit length should be kept the same as the design orbit
length by changing the momentum offset of the beam.
\item \verb|fixed_length_matrix| --- Indicates that for fixed-length orbit correction, the fixed-length
matrix should be computed and used.  This will improve convergence but isn't always needed.
\item \verb|n_xy_cycles| --- Number of times to alternate between correcting the x and y planes.
\item \verb|minimum_cycles| --- The minimum number of x-y cycles to perform, even if the correction does not improve.
\item \verb|n_iterations| --- Number of iterations of the correction in each plane for each x/y cycle.
\item \verb|prezero_correctors| --- Flag indicating whether to set the correctors to zero before starting.
\item \verb|track_before_and_after| --- Flag indicating whether tracking should be done both before and after
correction.
\item \verb|start_from_centroid| --- Flag indicating that correction
should start from the beam centroid.  For orbit correction, only the
beam momentum centroid is relevant.
\item \verb|use_actual_beam| --- Flag indicating that correction
should employ tracking of the beam distribution rather than a single
particle.  This is valid for trajectory correction only.
\item \verb|closed_orbit_accuracy| --- Accuracy of closed orbit computation.
\item \verb|closed_orbit_iterations| --- Number of iterations of closed orbit computation.
\item \verb|closed_orbit_iteration_fraction| --- Fraction of change in closed orbit to
use at each iteration.
\item \verb|use_perturbed_matrix| --- If nonzero, specifies that prior to each 
	correction \verb|elegant| shall recompute the response matrix.  This
	is useful if the lattice is changing significantly between corrections.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|correction_matrix_output|}\end{center}
\end{latexonly}
\subsection{correction\_matrix\_output \label{subsec:correctionmatrixoutput}}

\begin{itemize}
\item type: setup/action command.
\item function: provide output of the orbit/trajectory correction matrix.
\end{itemize}

\begin{verbatim}
&correction_matrix_output
    STRING response[4] = NULL, NULL;
    STRING inverse[2] = NULL, NULL;
    long KnL_units = 0;
    long BnL_units = 0;
    long output_at_each_step = 0;
    long output_before_tune_correction = 0;
    long fixed_length = 0;
    long coupled = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|response| --- Array of (incomplete) filenames for SDDS output of the x and y response
matrices, plus the cross-plane response matrices.  Recommended values, in order: ``\%s.hrm'' (horizontal
response to horizontal correctors), ``\%s.vrm'' (vertical response to vertical correctors),
``\%s.vhrm'' (vertical response to horizontal correctors), and 
``\%s.hvrm'' (horizontal response to vertical correctors).
\item \verb|inverse| --- Array of (incomplete) filenames for SDDS output of the x and y 
inverse response matrices. Recommended values: ``\%s.hirm'' and ``\%s.virm''.
\item \verb|KnL_units| --- Flag that, if set, indicates use of ``units'' of m/K0L rather than
m/rad.  This results in a sign change for the horizontal data.
\item \verb|BnL_units| --- Flag that, if set, indicates use of ``units'' of m/(T*m) rather than
m/rad.  This is useful for linac work in that the responses are automatically scaled with 
beam momentum.
\item \verb|output_at_each_step| --- Flag that, if set, specifies output of the data at
each simulation step.  By default, the data is output immediately for the defined lattice.
\item \verb|output_before_tune_correction| --- Flag that, if set, specifies that when 
\verb|output_at_each_step| is set, that output shall occur prior to correcting the tunes.
\item \verb|fixed_length| --- Flag that, if set, specifies output of the fixed-path-length
matrix.
\item \verb|coupled| --- If nonzero, the cross-plane response matrices are computed.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|correct_tunes|}\end{center}
\end{latexonly}
\subsection{correct\_tunes \label{subsec:correcttunes}}

\begin{itemize}
\item type: setup command.
\item function: set up for correction of the tunes.
\end{itemize}

\begin{verbatim}

&correct_tunes
    STRING quadrupoles = NULL;
    double tune_x = 0;
    double tune_y = 0;
    long n_iterations = 5;
    double correction_fraction = 0.9;
    double tolerance = 0;
    long step_up_interval = 0;
    double max_correction_fraction = 0.9;
    double delta_correction_fraction = 0.1;
    STRING strength_log = NULL;
    long change_defined_values = 0;
    long use_perturbed_matrix = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|quadrupoles| --- List of names of quadrupoles to be used.  Only two may be given.
\item \verb|tune_x|, \verb|tune_y| --- Desired x and y tune values.  If not given, the desired values are
assumed to be the unperturbed tunes.
\item \verb|n_iterations| --- The number of iterations of the correction to perform.
\item \verb|correction_fraction| --- The fraction of the correction to apply at each iteration.
\item \verb|tolerance| --- When both tunes are within this value of the desired tunes, the
iteration is stopped.
\item \verb|step_up_interval| --- Interval between increases in the correction fraction.
\item \verb|max_correction_fraction| --- Maximum correction fraction to allow.
\item \verb|delta_correction_fraction| --- Change in correction fraction after 
each \verb|step_up_interval| steps.
\item \verb|strength_log| --- The (incomplete) name of a SDDS file to which the quadrupole 
strengths will be written as correction proceeds.  Recommended value: ``\%s.qst''.
\item \verb|change_defined_values| --- Changes the defined values of the quadrupole strengths.
This means that when the lattice is saved (using \verb|save_lattice|), the quadrupoles will
have the corrected values.  This would be used for correcting the tunes of a design
lattice, for example, but not for correcting tunes of a perturbed lattice.
\item \verb|use_perturbed_matrix| --- If nonzero, requests use of the perturbed correction matrix in
performing correction.  For difficult lattices with large errors, this may be necessary
to obtain correction.  In general, it is not necessary and only slows the simulation.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|coupled_twiss_output|}\end{center}
\end{latexonly}
\subsection{coupled\_twiss\_output \label{subsec:coupledtwissoutput}}

\begin{itemize}
\item type: setup/action command.
\item function: set up or execute computation of coupled twiss parameters and beam sizes
\end{itemize}

\begin{verbatim}
&coupled_twiss_output
    STRING filename = NULL;
    long output_at_each_step = 0;
    long emittances_from_twiss_command = 1;
    double emit_x = 0;
    double emittance_ratio = 0.01;
    double sigma_dp = 0;
    long calculate_3d_coupling = 1;
    long verbosity = 0;
    long concat_order = 2;
&end
\end{verbatim}

\begin{itemize}

\item \verb|filename| --- The (incomplete) name of the SDDS file to which coupled twiss parameters and
  beam sizes will be written.  Suggested value: ``\%s.ctwi''.
\item \verb|output_at_each_step| --- If nonzero, then this is a setup
  command and results in computations occurring for each simulation
  step (e.g., for each perturbed machine if errors are included).  If
  zero, then this is an action command and computations are done
  immediately (e.g., for the unperturbed machine).
\item \verb|emittances_from_twiss_command| --- If nonzero, then the values of the horizontal emittance
  and the momentum spread are taken from the uncoupled computation done with the \verb|twiss_output| command.
  In this case, the user must issue a \verb|twiss_output| command prior to the \verb|coupled_twiss_output|.
  If zero, then the values of the horizontal emittance
  and the momentum spread are taken from the parameters \verb|emit_x| and \verb|sigma_dp|, respectively.
\verb \verb|emit_x| --- Gives the horizontal emittance, if \verb|emittances_from_twiss_command=0|.
\item \verb|emittance_ratio| --- Gives the ratio of the x and y emittances.  Used to determine the
  vertical emittance from the horizontal emittance.  Note that the computation is not self-consistent.
  I.e., the user is free to enter any emittance ratio desired, whether it is consistent with the
  machine optics or now.
\item \verb|sigma_dp| ---  Gives the momentum spread, if \verb|emittances_from_twiss_command=0|.
\end{itemize}

This feature was added to {\tt elegant} using code supplied by V. Sajaev, based on Ripkin's method.
The code computes the coupled lattice functions, then uses the supplied emittance, emittance ratio,
and momentum spread to compute the beam sizes, bunch length (if rf is included), and beam tilt.

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|divide_elements|}\end{center}
\end{latexonly}
\subsection{divide\_elements \label{subsec:divideelements}}

\begin{itemize}
\item type: setup command.
\item function: define how to subdivide certain beamline elements.
\item notes: 
	\begin{itemize}
	\item Any number of these commands may be given.  
	\item Not effective unless given prior to \verb|run_setup|.
	\item The \verb|element_divisions|
 field in \verb|run_setup| provides a simpler, but less flexible, method of performing
 element division.  At present, these element types may be divided: 
 \verb|QUAD|, \verb|SBEN|, \verb|RBEN|, \verb|DRIF|,  \verb|SEXT|.
	\item Only effective if given prior to the \verb|run_setup| command.
	\end{itemize}
\item warnings:	
	\begin{itemize}
	\item Using \verb|save_lattice| and element divisions together will
	produce an incorrect lattice file.
	\item Element subdivision may
	produce unexpected results when used with \verb|load_parameters|
	or parameters saved via the \verb|parameter|
	entry of the \verb|run_setup| command.
	If you wish to load parameters while doing element divisions or if
	you wish to load parameters from a run that had element divisions
	in effect, you should not load length data for any elements that
	are (or were) split.  The name and item pattern features of 
	\verb|load_parameters| are helpful in restricting what is loaded.
	\end{itemize}
\end{itemize}

\begin{verbatim}
&divide_elements
    STRING name = NULL;
    STRING type = NULL;
    STRING exclude = NULL;
    long divisions = 0;
    double maximum_length = 0;
    long clear = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|name| --- A possibly wildcard-containing string specifying
	the elements to which this specification applies.
\item \verb|type| --- A possibly wildcard-containing string specifying
 	the element types to which this specification applies.
\item \verb|exclude| --- A possibily wildcard-containing string specifying
 	elements to be excluded from the specification.
\item \verb|divisions| --- The number of times to subdivide the specified
	elements.  If zero, then \verb|maximum_length| should be nonzero.
\item \verb|maximum_length| --- The maximum length of a slice.  This is
	usually preferrable to specifying the number of divisions, particularly
	when the elements divided may be of different lengths.  If zero, then
	\verb|divisions| should be nonzero.
\item \verb|clear| --- If nonzero, all prior division specifications are
	deleted.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|error_element|}\end{center}
\end{latexonly}
\subsection{error\_element \label{subsec:errorelement}}

\begin{itemize}
\item type: setup command.
\item function: assert a random error defintion for the accelerator.
\end{itemize}

\begin{verbatim}
&error_element
    STRING name = NULL;
    STRING element_type = NULL;
    STRING item = NULL;
    STRING type = "gaussian";
    double amplitude = 0.0;
    double cutoff = 3.0;
    long bind = 1;
    long bind_number = 0;
    longn bind_across_names = 0;
    long post_correction = 0;
    long fractional = 0;
    long additive = 1;
    long allow_missing_elements = 0;
    STRING after = NULL;
    STRING before = NULL;
&end
\end{verbatim}

\begin{itemize}
\item \verb|name| --- The possibly wildcarded name of the elements for which errors are being specified.
\item \verb|element_type| --- An optional, possibly wildcarded string giving the type of elements to
 which the errors should be applied.  E.g., \verb|element_type=*MON*| would match all beam position monitors.
 If this item is given, then \verb|name| may be left blank.
\item \verb|item| --- The parameter of the elements to which the error pertains.
\item \verb|type| --- The type of random distribution to use.  May be one of ``uniform'', ``gaussian'', or ``plus\_or\_minus''.
A ``plus\_or\_minus'' error is equal in magnitude to the amplitude given, with the sign randomly chosen.
\item \verb|amplitude| --- The amplitude of the errors.
\item \verb|cutoff| --- The cutoff for the gaussian random distribution in units of the amplitude.  Ignored for other distribution types.
\item \verb|bind|, \verb|bind_number|, \verb|bind_across_names| ---
These parameters control ``binding'' of errors among elements, which
means assigning the same error contribution to several elements.  This
occurs if \verb|bind| is nonzero, {\bf which it is by default}! If \verb|bind| is negative, then the
sign of the error will alternate between successive elements.
\verb|bind_number| can be used to limit the number of elements bound
together. In particular, if \verb|bind_number| is positive, then a
positive value of \verb|bind| indicates that \verb|bind_number|
successive elements having the same name will have the same error
value.  Finally, by default, {\tt elegant} only binds the errors of
objects having the same name, even if they are assigned errors by 
the same \verb|error_element| command (i.e., through a wildcard \verb|name|).
If \verb|bind_across_names| is nonzero, then binding is done even for elements
with different names.

\item \verb|post_correction| --- A flag indicating whether the errors should be added after orbit, tune, and chromaticity correction.
\item \verb|fractional| --- A flag indicating whether the errors are fractional, in which case the amplitude refers to
the amplitude of the fractional error.
\item \verb|additive| --- A flag indicating that the errors should be added to the prior value of the
parameter.  If zero, then the errors replace the prior value of the parameter.
\item \verb|allow_missing_elements| --- A flag indicating that execution may continue even if no matching elements are found.
\item \verb|after| --- The name of an element.  If given, the error is applied only to elements
 that follow the named element in the beamline.
\item \verb|before| --- The name of an element.  If given, the error is applied only to elements
 that precede the named element in the beamline.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|error_control|}\end{center}
\end{latexonly}
\subsection{error\_control \label{subsec:errorcontrol}}

\begin{itemize}
\item type: setup command
\item function: overall control of random errors.
\end{itemize}

\begin{verbatim}
&error_control
    long clear_error_settings = 1;
    long summarize_error_settings = 0;
    long no_errors_for_first_step = 0;
    STRING error_log = NULL;
    double error_factor = 1;
&end
\end{verbatim}

\begin{itemize}
\item \verb|clear_error_settings| --- Clear all previous error settings.
\item \verb|summarize_error_settings| --- Summarize current error settings.
\item \verb|no_errors_for_first_step| --- If non-zero, then there will be no errors for the first step.  This can be useful for
 fiducialization of phase and momentum profiles.
\item \verb|error_log| --- The (incomplete) name of a SDDS file to which error values will be written.  Recommended value: ``\%s.erl''.
\item \verb|error_factor| --- A value by which to multiply the error amplitudes in all \verb|error| commands.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|find_aperture|}\end{center}
\end{latexonly}
\subsection{find\_aperture \label{subsec:findaperture}}

\begin{itemize}
\item type: setup/major action command.
\item function: find the aperture in (x, y) space for an accelerator.
\end{itemize}

\begin{verbatim}
&find_aperture
    STRING output = NULL;
    STRING search_output = NULL;
    STRING boundary = NULL;
    STRING mode = "many-particle";
    double xmin = -0.1;
    double xmax =  0.1;
    double ymin =  0.0;
    double ymax =  0.1;
    long nx  = 21;
    long ny  = 11;
    long n_splits = 0;
    double split_fraction = 0.5;
    double desired_resolution = 0.01;
    long assume_nonincreasing = 0;
    long verbosity = 0;    
    long offset_by_orbit = 0;
    long n_lines = 11;
    long optimization_mode = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|output| --- The (incomplete) name of an SDDS file to send output to.  
 Recommended value: ``\%s.aper''.

\item \verb|mode| --- May be ``many-particle'', ``single-particle'', ``one-line, ``three-lines'', or ``n-lines''.
Many-particle searching is much
faster than single-particle, but does not allow interval splitting to
search for the aperture boundary.  Both ``many-particle'' and
``single-particle'' modes involve searching from the outside inward,
which improves speed but may result in including islands.

The line modes avoid this by searching form the origin
outward.  Of these, the one-line and three-line modes are special:
one-line mode searches the line from the origin to $(x_{max},
y_{max})$.  three-line mode searches this line, plus the lines from
the origin to $(x_{max}, 0)$ and $(0, y_{max})$.  

For n-line mode, the number of lines is set with the \verb|n_lines| parameter.
With $n>3$, $n$ lines are explored from $(0,0)$ to
$(x_{max}*sin(\theta), y_{max}*cos(\theta))$, where $\theta$ takes
values from $-pi/2$ to $\pi/2$.   In these modes, the output file contains
a parameter called ``Area,'' which gives the area of the dynamic aperture.

Also still recognized are other modes, namely, ``five-line'', ``seven-line'', ``nine-line'',
and ``eleven-line''.

\item \verb|search_output| --- The (incomplete) name of an SDDS file for output of detailed
 information on each tracked particle (single-particle mode only).  Recommended value:
 ``\%s.apso''.

\item \verb|boundary| --- The (incomplete) name of an SDDS 
file for the boundary points of the aperture search.  Recommended value: ``\%s.bnd''.
Valid for many- and single-particle modes.

\item \verb|xmin|, \verb|xmax|, \verb|ymin|, \verb|ymax| --- Region of the aperture search.
The minimum values are relevant only for many- and single-particle modes.

\item \verb|nx| --- For many- and single-particle modes, the number of x values to take in initial search.
  For line modes, this determines the initial x and y step sizes via $\Delta x = x_{max}/n_x$ and
  $\Delta y = y_{max}/n_x$.
\item \verb|ny| --- For many- and single-particle modes, the number of y values to take in search.
  Ignored for line modes.

\item \verb|n_splits| --- If positive, the number of times to do
interval splitting.  Interval splitting refers to searching between
the original grid points in order to refine the results.  This is done
only for single-particle and line modes.

\item \verb|split_fraction| --- If interval splitting is done, how the interval is split.

\item \verb|desired_resolution| --- If interval splitting is done,
fraction of \verb|xmax-xmin| to which to resolve the aperture.  Ignored for all but single-particle
mode.

\item \verb|assume_nonincreasing| --- If this variable is non-zero, the search assumes that the aperture
at ${\rm y+sign(y)*\Delta y}$ is no larger than that at ${\rm y}$.  This results in tracking of
fewer particles but may give a pessimistic result.    Used only for single- and multi-particle
modes.

\item \verb|offset_by_orbit| --- A flag indicating whether to offset
the transverse beam coordinates by the closed orbit before tracking.  The default value is
zero for backward compatibility, but the recommended value is 1.

\item \verb|verbosity| --- A larger value results in more printouts during computations.

\item \verb|n_lines| --- In ``n-lines'' mode, the number of lines to search.

\item \verb|optimization_mode| --- If non-zero, then \verb|find_aperture| is a setup command and can be used
with {\tt elegant}'s internal optimizer.  The quantity \verb|Area| is defined, giving the area of the dynamic
aperture for use in the penalty function.  This is available only for the line search modes.

\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|floor_coordinates|}\end{center}
\end{latexonly}
\subsection{floor\_coordinates \label{subsec:floorcoordinates}}

\begin{itemize}
\item type: action command.
\item function: compute floor coordinates for an accelerator.
\end{itemize}

\begin{verbatim}
&floor_coordinates
    STRING filename = NULL;
    double X0 = 0.0;
    double Z0 = 0.0;
    double theta0 = 0.0;
    long include_vertices = 0;
    long vertices_only = 0;
    long magnet_centers = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|filename| --- The (incomplete) name of an SDDS file to send output to.  
 Recommended value: ``\%s.flr''.
\item \verb|X0|, \verb|Z0|, \verb|theta0| --- Initial X, Z, and angle coordinate of the beamline.
\item \verb|include_vertices| --- Flag that, if set, specifies including  in the output
the coordinates of the vertices of bending magnets.
\item \verb|vertices_only| --- Flag that, if set, specifies that output will contain only
the coordinates of the vertices of bending magnets.
\item \verb|magnet_centers| --- Flag that, if set, specifies that output will contain 
the coordinates of the centers of all magnets.  By default, the coordinates of the downstream
end are given.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|frequency_map|}\end{center}
\end{latexonly}
\subsection{frequency\_map \label{subsec:frequencymap}}

\begin{itemize}
\item type: major action command.  
\item function: compute frequency map from tracking
      Note that the number of turns tracked is set by the \verb|run_control| command.
\end{itemize}

\begin{verbatim}
&frequency_map
    STRING output = NULL;
    double xmin = -0.1;
    double xmax = 0.1;
    double ymin = 1e-6;
    double ymax = 0.1;
    double delta_min = 0;
    double delta_max = 0;
    long nx = 21;
    long ny = 21;
    long ndelta = 1;
    long verbosity = 1;
    long include_changes = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|output| --- The (incomplete) name of an SDDS file to send output to.  
 Recommended value: ``\%s.fma''.  For the parallel version, particles will be listed in essentially
 random order.  If needed, \verb|sddssort| can be used to sort particles by initial coordinates.
\item \verb|xmin|, \verb|xmax| --- Limits of grid of initial x coordinates for tracking.             
\item \verb|ymin|, \verb|ymax| --- Limits of grid of initial y coordinates for tracking.             
 \verb|ymin| should typically be a small, positive value so that there                               
 is some betatron oscillation from which to get the tune.                      
\item \verb|delta_min|, \verb|delta_max| --- Limits of grid of initial $\delta$ coordinates
for tracking.  Not that particles are not centered around the dispersive closed orbit.  Hence,
the tracking is appropriate to simulation of dynamics from a touschek scattering event.
\item \verb|nx| --- Number of values of x coordinate in the grid.
\item \verb|ny| --- Number of values of y coordinate in the grid.
\item \verb|ndelta| --- Number of values of $\delta$ coordinate in the grid.
\item \verb|verbosity| --- If nonzero, prints possibly useful information while running.
\item \verb|include_changes| --- If nonzero, then computes not only the tunes, but also
        the changes in the tunes.  This is expressed in terms of the diffusion, which is defined
        as 
\begin{equation}
  d = \log \left(\Delta\nu_x^2 + \Delta\nu_y^2\right)
\end{equation}
Use of this feature results in a doubling of the number of turns tracked.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|global_settings|}\end{center}
\end{latexonly}
\subsection{global\_settings \label{subsec:globalsettings}}

\begin{itemize}
\item type: action command.  
\item function: change global settings.
\end{itemize}

\begin{verbatim}
&global_settings
    long inhibit_fsync = 0;
    long echo_namelists = 1;
    STRING log_file = NULL;
    STRING error_log_file = NULL;
&end
\end{verbatim}

\begin{itemize}
\item \verb|inhibit_fsync| --- By default, \verb|elegant| forces file synchronization across a network file system
  to ensure that users see up-to-date files as soon as possible.  In cases where a great deal of output is generated,
  this can degrade performance.  Setting this parameter to 1 will turn off synchronization until the end of the run.
\item \verb|echo_namelists| -- By default, \verb|elegant| echoes all namelist input to the terminal.  If this parameter
  is set to 0, this output will be inhibited.
\item \verb|log_file| --- By default, \verb|elegant| writes status information to the terminal.  If a filename is supplied
  for this parameter, the output will instead go to the file.  On Linux and Unix, using \verb|/dev/null| will result in 
  the output being discarded.
\item \verb|error_log_file| --- By default, \verb|elegant| writes error messages to the terminal.  If a filename is supplied
  for this parameter, the output will instead go to the file.  On Linux and Unix, using \verb|/dev/null| will result in 
  the output being discarded.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|insert_elements|}\end{center}
\end{latexonly}
\subsection{insert\_elements \label{subsec:insertelements}}

\begin{itemize}
\item type: action command.
\item function: Insert elements into a beamline at specified locations. This is a convenient way to
 add elements to a beamline without modifying the lattice file.
\item notes: 
	The modified beamline can be saved through \verb|save_lattice|
   command. Be sure to use ``output\_seq = 1'' option in that command.  
\end{itemize}

\begin{verbatim}
&insert_elements
        STRING name = NULL;
        STRING type = NULL;
        STRING exclude = NULL;
        long skip = 1;
        long disable = 0;
        long add_at_end = 0;
        STRING element_def = NULL;
        long total_occurrences = 0;
        long occurrence[100]={0};
&end
\end{verbatim}

\begin{itemize}
\item \verb|name| --- Possibly wild-card containing string specifying the
   name of the elements after which the new element is inserted.
\item \verb|type| --- Possibly wild-card containing string specifying the
   type of the elements after which the new element is inserted.
\item \verb|exclude| --- Possibly wild-card containing string specifying 
   the names of elements to be excluded from the specification.
\item \verb|skip| --- New elements are inserted at every $n^{th}$ specified location.
\item \verb|disable| --- If nonzero, the command is ignored.
\item \verb|add_at_end| --- If nonzero, the element is also inserted to the end of the beamline.
\item \verb|element_def| --- The definition of the new element should be just as it would be entered in 
the lattice file.
\item \verb|total_occurrences|, \verb|occurrence| --- 
These parameters are used to insert the new elements after specified occurrences of 
the element \verb|name|.  \verb|total_occurrences| specifies how many new elements to add,
up to a maximum of 100, while the entries in the array \verb|occurrence| specify the occurrences
after which to add the new elements. If \verb|total_occurrences| is non-zero, then {\bf skip} must
be set to zero  and the {\bf name} must be the exact name (no wild-card matching). 
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|insert_sceffects|}\end{center}
\end{latexonly}
\subsection{insert\_sceffects \label{subsec:insertsceffects}}

\begin{itemize}
\item type: setup command.
\item function: set up for transverse space charge calculation.  
\item {\bf This feature can not work with concatenation matrix tracking.}
\item {\bf
N.B.: This feature is not designed for space charge calculations in
guns or linacs.  It is only intended for simulating space charge in
rings. }
\end{itemize}

\begin{verbatim}
&insert_sceffects
        STRING name = NULL;
        STRING type = NULL;
        STRING exclude = NULL;
        long disable = 0;
        long clear = 0;
        STRING element_prefix = "MYSC";
        long skip = 0;
        long vertical = 0;
        long horizontal = 0;
        long nonlinear = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|name| --- Possibily wild-card containing string specifying the
	name of the elements after which to insert the space charge kick element.
\item \verb|type| --- Possibily wild-card containing string specifying the
        type of the elements after which to insert the space charge kick element.
\item \verb|exclude| --- Possibily wild-card containing string specifying 
	the name of elements to be excluded from the insertion of the space charge kick element.
\item \verb|disable| --- If nonzero, the command is ignored.
\item \verb|clear| --- If nonzero, all prior space charge insertions are deleted.
\item \verb|element_prefix| --- Name under which the space charge kick will appear in the beamline.
\item \verb|skip| --- If nonzero, the given number of insertion locations are skipped. 
        If zero, only one space charge kick is inserted at the end of beamline. 
\item \verb|vertical|, \verb|horizontal|, \verb|nonlinear| --- If non-zero, then space charge is
included in the plane in question.
\end{itemize}

Note: Some users use \verb|matched_to_cell| or
\verb|use_twiss_command_values| in the \verb|bunched_beam|
command. Those options will erase SCMULT assignments along the
beamline. In this case, user has to re-calculate twiss using
\verb|twiss_output| just before tracking.

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|linear_chromatic_tracking_setup|}\end{center}
\end{latexonly}
\subsection{linear\_chromatic\_tracking\_setup \label{subsec:linearchromatictrackingsetup}}

\begin{itemize}
\item type: setup command.
\item function: define chromatic variation of beta functions, tunes, etc. for using in
 fast linear-chromatic tracking
\end{itemize}

\begin{verbatim}
&linear_chromatic_tracking_setup
    double nux[4] = {-1, 0, 0, 0};
    double betax[2] = {1.0, 0.0};
    double alphax[2] = {0.0, 0.0};
    double etax[2] = {0.0, 0.0};
    double etapx[2] = {0.0, 0.0};
    double nuy[4] = {-1, 0, 0, 0};
    double betay[2] = {1.0, 0.0};
    double alphay[2] = {0.0, 0.0};
    double etay[2] = {0.0, 0.0};
    double etapy[2] = {0.0, 0.0};
    double alphac[2] = {0.0, 0.0};
&end
\end{verbatim}

\begin{itemize}
\item \verb|nux| --- Provide the horizontal tune plus its first three chromatic derivatives, i.e.,
  $\partial \nu_x/\partial\delta$, $\partial^2 \nu_x/\partial\delta^2$, and
  $\partial^3 \nu_x/\partial\delta^3$.
\item \verb|betax| --- Provide the horizontal beta function plus its chromatic derivative.
\item \verb|alphax| --- Provide the horizontal alpha function plus its chromatic derivative.
\item \verb|etax| --- Provide the first- and second-order horizontal dispersion:
  $\eta_x = \eta_x\left[0\right] + \eta_x\left[1\right]\delta$.
\item \verb|etapx| --- Provide the first- and second-order horizontal dispersion slope.
\item \verb|alphac| --- Provide the first and second-order momentum compaction.  N.B: if you are tracking
 with an rf cavity, be sure that your lattice length equal to the actual circumference.  See the example below.
\end{itemize}

An example of a good lattice for use with this feature is the following:
\begin{verbatim}
! Actual length of the ring
d0: drift,l=30.6667
! Actual rf voltage and frequency
rf: rfca,l=0,volt=30e3,phase=180,freq="c_mks 30.6667 /"
w1: watch,filename="%s.w1",mode="centroid"
ring: line=(d0,rf,w1)
\end{verbatim}
Any additional elements (e.g,. wakes or impedances) should follow d0.  No other elements represented by a matrix
should be present!

An alternative for using this command is to use {\tt ILMATRIX} elements in the lattice definition.  This is more
flexible, since one can include tune shifts with amplitude.

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|link_control|}\end{center}
\end{latexonly}
\subsection{link\_control \label{subsec:linkcontrol}}

\begin{itemize}
\item type: setup command.
\item function: overall control of element parameter links.
\end{itemize}

\begin{verbatim}
&link_control
    long clear_links = 1;
    long summarize_links = 0;
    long verbosity = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|clear_links| --- Clear all previously set links.
\item \verb|summarize_links| --- Summarize all current set links.
\item \verb|verbosity| --- A larger value results in more output
during computations.

\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|link_elements|}\end{center}
\end{latexonly}
\subsection{link\_elements \label{subsec:linkelements}}

\begin{itemize}
\item type: setup command.
\item function: assert a link between parameters of accelerator elements.
\end{itemize}

\begin{verbatim}
&link_elements
    STRING target = NULL;
    STRING exclude = NULL;
    STRING item = NULL;
    STRING source = NULL;
    STRING source_position = "before";
    STRING mode = "dynamic";
    STRING equation = NULL;
    double minimium = -DBL_MAX;
    double maximum = DBL_MAX;
&end
\end{verbatim}

\begin{itemize}
\item \verb|target| --- The name of the elements to be modified by the link.  May contain
 wild-cards.
\item \verb|exclude| --- Wildcard sequence to match to element names.  If a match is found,
 the element is excluded from the link.
\item \verb|item| --- The parameter that will be modified.
\item \verb|source| --- The name of the elements to be linked to.
\item \verb|source_position| --- May be one of ``before'', ``after'', 
``adjacent'', ``nearest'', or ``same-occurrence''.
\item \verb|mode| --- May be either ``dynamic'' or ``static''.  A dynamic link
is asserted whenever the source is changed (during correction, for example).  
A static link is asserted only when an error or variation is imparted to
the source, and at the end of correction.
\item \verb|equation| --- An {\tt rpn} equation for the new item value in
terms of the item values for the source.  The prior value of the item is 
on the top of the stack. To refer to the source
parameter values, use the name of the parameters. To refer to the initial source
parameter values, append ``0'' to the parameter name.  These names must appear
in capital letters.  
\item \verb|minimum|, \verb|maximum| --- Minimum and maximum values that will be
assigned to the target parameter.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|load_parameters|}\end{center}
\end{latexonly}
\subsection{load\_parameters \label{subsec:loadparameters}}

\begin{itemize}
\item type: setup command.
\item function: load parameters for elements from an SDDS file.
\end{itemize}

\begin{verbatim}
&load_parameters
        STRING filename = NULL;
        STRING filename_list = NULL;
        STRING include_name_pattern = NULL;
        STRING exclude_name_pattern = NULL;
        STRING include_item_pattern = NULL;
        STRING exclude_item_pattern = NULL;
        STRING include_type_pattern = NULL;
        STRING exclude_type_pattern = NULL;
        long change_defined_values = 0;
        long clear_settings = 0;
        long allow_missing_elements = 0;
        long allow_missing_parameters = 0;
	long force_occurence_data = 0;
        long verbose = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|filename| --- Name (possibly containing the ``%s'' field) 
of SDDS file from which to take data.  The file
must contain some of the following columns:
\begin{itemize}
\item ElementName --- Required string column.  The name of the element to change.
\item ElementParameter --- Required string column.  The name of the parameter of the element to change.
\item ParameterValue --- Optional double column.  If given, gives value of the parameter named
 in ElementParameter for element named in ElementName.
\item ParameterValueString --- Optional string column.  If ParameterValue is not present, then
this column must be present.  The string data will be scanned, if necessary,
to obtain a value for the parameter.
\item ParameterMode --- Optional string column.  If given, for each row the value must be
one of ``absolute'', ``differential'', ``ignore'', or ``fractional''.  The meaning of these
modes is as follows: absolute mode means the given value is used as the new value for
the parameter; differential mode means the given value is added to the existing value
for the parameter; ignore mode means the value is ignored; fractional mode means the
existing value is increased by the product of the given value and the existing value 
(i.e., the given value is a fractional change).
\end{itemize}

Unless \verb|change_defined_values| is set, successive pages of the
file are used for successive steps of the simulation.  Several {\tt
elegant} commands generate output that may be used (on a subsequent
run) with \verb|load_parameters|; among these are the tune and
chromaticity correction commands and the \verb|run_setup| command
(parameters output).

\item \verb|filename_list| --- A list of filenames, which may be 
        given in place of \verb|filename|.  If used, each file
        in the list is treated as if it was separately supplied
        with an individual \verb|load_parameters| command.

\item \verb|include_name_pattern|, \verb|exclude_name_pattern| ---
Wildcard patterns to be used in selecting, respectively, which
elements to include and which to exclude from loading.

\item \verb|include_item_pattern|, \verb|exclude_item_pattern| ---
Wildcard patterns to be used in selecting, respectively, which items
(i.e., which element parameters) to include and which to exclude from
loading.

\item \verb|include_type_pattern|, \verb|exclude_type_pattern| ---
Wildcard patterns to be used in selecting, respectively, which element
types (e.g., QUAD, DRIFT) to include and which to exclude from
loading.

\item \verb|change_defined_values| --- Changes the defined values of
the parameters.  This means that when the lattice is saved (using
\verb|save_lattice|), the parameters will have the altered values.
Also, if one wants to alter the values for all steps of the simulation,
one must set this flag. 

Note that the \verb|ElementOccurence| data is normally ignored if
\verb|change_defined_values| is nonzero.  This is because there is
only one definition of each element, even if it is used multiple times.
This behavior can be altered with the next control.

\item \verb|force_occurence_data| --- If set, then occurence data is
used even in \verb|change_defined_values| mode.

\item \verb|clear_settings| --- If set, clear all settings and files
being used for loading parameters.

\item \verb|allow_missing_elements| --- If set, allow elements in the
file that are not in the lattice.  In this case, the nonapplicable
data is simply ignored.

\item \verb|allow_missing_parameters| --- If set, it is not an error
if any element in the lattice lacks a parameter that exists in the file.

\item \verb|verbose| --- If set, provide informational printouts about
changes to parameters.

\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|matrix_output|}\end{center}
\end{latexonly}
\subsection{matrix\_output \label{subsec:matrixoutput}}

\begin{itemize}
\item type: setup/action command.
\item function: generate matrix output, or set up to do so later.
\end{itemize}

\begin{verbatim}
&matrix_output
    STRING printout = NULL;
    long printout_order = 1;
    long full_matrix_only = 0;
    STRING SDDS_output = NULL;
    long SDDS_output_order = 1;
    long individual_matrices = 0;
    STRING SDDS_output_match = NULL;
    long output_at_each_step = 0;
    STRING start_from = NULL;
    long start_from_occurrence = 1;
&end
\end{verbatim}

\begin{itemize}
\item \verb|printout| --- The (incomplete) name of a file to which the 
matrix output will be printed (as text).  Recommended value: ``\%s.mpr''.
\item \verb|printout_order| --- The order to which the matrix is printed.
\item \verb|full_matrix_only| --- A flag indicating that only the matrix of
the entire accelerator is to be output.
\item \verb|SDDS_output| --- The (incomplete) name of an SDDS 
file to which the matrix will be written.  Recommended value: ``\%s.mat''.
\item \verb|SDDS_output_order| --- The order to which the matrix is output in SDDS format.
\item \verb|individual_matrices| --- If non-zero, the matrices in the SDDS file are the individual
{\em on-trajectory} matrices of the elements, rather than the concatenated matrix of the beamline.
\item \verb|SDDS_output_match| --- A wildcard string which element names must match in
order for data to appear in the SDDS output file.
\item \verb|output_at_each_step| --- A flag indicating whether matrix output
is desired at every simulation step.
\item \verb|start_from| --- The optional name of the accelerator element
from which to begin concatenation and output.
\item \verb|start_from_occurrence| --- If \verb|start_from| is not NULL, the
number of the occurrence of the named element from which to start.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|modulate_elements|}\end{center}
\end{latexonly}
\subsection{modulate\_elements\label{subsec:modulateelements}}

\begin{itemize}
\item type: setup command.
\item function: define parameters for time-dependent modulation of elements
\item N.B.: this feature is somewhat experimental.  Please use with caution and report any problems on the forum.
\end{itemize}

\begin{verbatim}
&modulate_elements
    STRING name = NULL;
    STRING item = NULL;
    STRING type = NULL;
    STRING expression = NULL;
    STRING filename = NULL;
    STRING time_column = NULL;
    STRING amplitude_column = NULL;
    long differential = 1;
    long multiplicative = 0;
    long start_occurence = 0;
    long end_occurence = 0;
    double s_start = -1;
    double s_end = -1;
    STRING before = NULL;
    STRING after = NULL;
    long verbose = 0;
&end
\end{verbatim}

N.B.: This command will produce unpredictable results when used with
\verb|error_element|, \verb|alter_elements|, and
\verb|load_parameters| (except when \verb|change_defined_values=1|).
It should work properly with \verb|link_elements| in turn-by-turn mode
when the source element is modulated, but not when the target element
is modulated.

\begin{itemize}
\item \verb|name| --- A possibly-wildcard-containing string giving the names of the
        elements to modulate. If not specified, then one must specify \verb|type|.
\item \verb|item| --- The name of the parameter to modulate.
\item \verb|type| --- A possibly-wildcard-containing string giving the names of element
        {\em types} to modulate.  May be specified with \verb|name| or by itself.
\item \verb|expression| --- RPN expression for the modulation amplitude $A$.  The value
  of the time is on top of the stack. 
\item \verb|filename| --- Name of SDDS file from which to read modulation data, if
  \verb|expression| is not used.
\item \verb|time_column| --- Name of column in \verb|filename| giving time data for the
  modulation table.
\item \verb|amplitude_column| --- Name of column in \verb|filename| giving amplitude data
  for the modulation.  Together, \verb|time_column| and \verb|amplitude_column| define
  a function $A(t)$.
\item \verb|differential|, \verb|multiplicative| --- Determine how the amplitude function
  $A(t)$ is used to obtain the new value of the parameter.  There are four cases
  \begin{itemize}
    \item \verb|differential=1|, \verb|multiplicative=0|: $v(t) = v_0 + A(t)$ (default).
    \item \verb|differential=0|, \verb|multiplicative=0|: $v(t) = A(t)$.  
    \item \verb|differential=1|, \verb|multiplicative=1|: $v(t) = v_0 + v_0 A(t)$.  
    \item \verb|differential=0|, \verb|multiplicative=1|: $v(t) = v_0 A(t)$.  
  \end{itemize}
\item \verb|start_occurence|, \verb|end_occurence| --- If nonzero, these give the starting and
 ending occurrence numbers of elements that will be modulated. N.B.: if wildcards are used, occurrence
 number counting is for each set of identically-named elements separately, rather than for the sequence
 of matched elements.
\item \verb|s_start|, \verb|s_end| --- If non-negative, these give the gaving and ending position
 limits for the end-of-element locations of elements to be modulated.
\item \verb|after| --- The name of an element.  If given, the modulation is applied only to elements
 that follow the named element in the beamline.  
\item \verb|before| --- The name of an element.  If given, the modulation is applied only to elements
 that precede the named element in the beamline. 
\item \verb|verbose| --- If nonzero, information is printed to the standard output as changes are
        made.  Use for debugging only, since otherwise it may slow the simulation.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|moments_output|}\end{center}
\end{latexonly}
\subsection{moments\_output \label{subsec:momentsoutput}}

\begin{itemize}
\item type: action/setup command.
\item function: compute periodic or non-periodic beam moments, optionally including radiation
\end{itemize}

\begin{verbatim}
&moments_output
    STRING filename = NULL;
    long output_at_each_step = 0;
    long output_before_tune_correction = 0;
    long final_values_only = 0;
    long verbosity = 0;
    long matched = 1;
    long equilibrium = 1;
    long radiation = 1;
    long n_slices = 10;
    double emit_x = 0;
    double beta_x = 0;
    double alpha_x = 0;
    double eta_x = 0;
    double etap_x = 0;
    double emit_y = 0;
    double beta_y = 0;
    double alpha_y = 0;
    double eta_y = 0;
    double etap_y = 0;
    double emit_z = 0;
    double beta_z = 0;
    double alpha_z = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|filename| --- The (incomplete) name of a file to which the moments results will be written.
  Recommended value: ``\%s.mom''.
\item \verb|output_at_each_step| --- A flag indicating, if set, that computations and/or output is desired at each step of the simulation.
\item \verb|output_before_tune_correction| --- A flag indicating, if set, that output is desired both before and after
tune correction.
\item \verb|final_values_only| --- A flag indicating, if set, that only the final values of the Twiss parameters should
be output, and not the parameters as a function of s.
\item \verb|verbosity| --- Larger numbers result in an increasing amount of informational output to the standard output stream.
\item \verb|matched| --- A flag indicating, if set, that the periodic or matched moments should be found.
\item \verb|equilibrium| --- A flag indicating, if set, that the equilibrium moments should be found.  If \verb|matched=1| and \verb|equilibrium=0|,
  then the initial twiss parameters are computed from the periodic solution for the beamline.
\item \verb|radiation| --- A flag indicating, if set, that synchrotron radiation effects should be included.
\item \verb|n_slices| --- The number of slices into which to cut individual dipoles, quadrupoles, and sextuoples for computations.
  10 has been found to work for all rings tested, but users are advised to ensure it is sufficient for their cases.
\item \verb|emit_x|, \verb|beta_x|, \verb|alpha_x|, \verb|eta_x|, \verb|etap_x|, and related quantities for \verb|y| and \verb|z| ---
  If \verb|matched=0|, then these specify the starting beam ellipses in all three planes.
\end{itemize}

This command performs several functions.  In the most basic form, it
propagates beam moments, i.e., the 6x6 sigma matrix, from the
beginning to the end of a transport line, including coupling from
rotated elements or offset sextupoles. This can be performed with or
without synchrotron radiation effects in dipoles, quadrupoles, and sextupoles.
({\em NB: radiation effects are not yet included for wigglers!})  These computations
include the evolution of the trajectory due to errors and (if included)
synchrotron radiation.

If desired, the command will instead compute the periodic beam
moments.  In this case, the user must include an appropriate rf cavity
in the lattice in order to get valid results.  (By ``appropriate rf
cavity'' we mean that it must have the right voltage, frequency, and
phase to support stored beam.)  It is also suggested that the user
compute the closed orbit using \verb|closed_orbit| so that the
computations are performed on the closed orbit.

The results of moments computation may be subjected to optimization
using values at marker elements.  See the documentation for
\verb|MARK| for more details.

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|momentum_aperture|}\end{center}
\end{latexonly}
\subsection{momentum\_aperture \label{subsec:momentumaperture}}

\begin{itemize}
\item type: major action command.
\item function: determine momentum aperture as a function of position in the lattice by tracking
\end{itemize}

\begin{verbatim}
&momentum_aperture
    STRING output = NULL;
    double x_initial = 0;
    double y_initial = 0;
    double delta_negative_start = 0.0;
    double delta_positive_start = 0.0;
    double delta_negative_limit = -0.10;
    double delta_positive_limit = 0.10;
    double delta_step_size = 0.01;
    long steps_back = 1;
    long splits = 2;
    long split_step_divisor = 10;
    long skip_elements = 0;
    long process_elements = 2147483647;
    double s_start = 0;
    double s_end = DBL_MAX;
    STRING include_name_pattern = NULL;
    STRING include_type_pattern = NULL;
    long fiducialize = 0;
    long verbosity = 1;
    long soft_failure = 0;
    long output_mode = 0;
    long forbid_resonance_crossing = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|output| --- The (incomplete) name of a file to which the momentum aperture results will be written.
  Recommended value: ``\%s.mmap''.
\item \verb|x_initial|, \verb|y_initial| --- The initial x and y coordinate values for tracking. It is essential
 that \verb|y_initial| be nonzero if one wants to see losses due to vertical resonances.  
\item \verb|delta_negative_start|, \verb|delta_positive_start| ---
Starting values of scans in the negative and positive
directions. 
\item \verb|delta_negative_limit|, \verb|delta_positive_limit| ---
Limiting values of scans in the negative and positive
directions. 
\item \verb|delta_step_size| --- Initial size of steps in $\delta$.  This should
 be fairly large in order to save time.

\item \verb|steps_back| --- Number of steps to back up after a particle is lost,
 relative to the last surviving $\delta$, before continuing with a smaller step size.
 If this is set to zero, there is a risk of finding a too-large momentum aperture
 (a stable island).

\item \verb|splits| --- Number of times to split the step size in
 order to refine the location of the maximum surviving momentum
 offsets.  When a particle is lost, the algorithm steps back to a momentum offset
 where a particle survived, subdivides the step size, and continues searching.  

\item \verb|split_step_divisor| --- Factor by which to subdivide the step size
  for each split.

\item \verb|skip_elements| --- Number of elements to skip before starting to
  compute momentum apertures.

\item \verb|process_elements| --- Number of elements for which to compute
  momentum aperture.

\item \verb|s_start|, \verb|s_end| --- Limiting s coordinates of the
 elements from which tracking will start.  The default values will
 exclude no elements.

\item \verb|include_name_pattern| --- If given, tracking will start
only at the entrance to elements that match the given wildcard
pattern.

\item \verb|include_type_pattern| --- If given, tracking will start
only at the entrance to elements whose type matches the given wildcard
pattern.

\item \verb|fiducialize| --- If given, an initially on-energy particle is tracked before
 the momentum aperture search begins, in order to fiducialize the reference momentum.
 This is useful if there are synchrotron radiation losses or energy gain due to cavities
 in the system.

\item \verb|verbosity| --- Larger values result in more detailed
printouts as calculations proceed.  Mostly for debugging.

\item \verb|soft_failure| --- Normally, if {\tt elegant} fails to find the momentum aperture,
it aborts.  If \verb|soft_failure| is non-zero, it instead assigns a momentum aperture equal
to the search limit.

\item \verb|output_mode| --- Normally, {\tt elegant} puts the values for positive and
negative momentum aperture in different columns.  Each element thus has a single row of
data in the output file.  If \verb|output_mode| is nonzero, {\tt elegant} instead puts
the values for positive and negative apertures in successive rows, with a reduced number
of columns.  This is mostly advantageous for the parallel version, since it allows using
twice as many simultaneous processors.

\item \verb|forbid_resonance_crossing| --- Normally, {\tt elegant} allows the momentum
aperture search to cross integer and half-integer resonances if no unstable particles are
found.  If this is undesirable, this flag can be set to 1.
\end{itemize}

The idea for this command is from M. Belgroune {\em et al.}, ``Refined
Tracking Procedure for the SOLEIL Energy Acceptance Calculation,''
Proceedings of PAC 2003, p 896, as implemented for TRACYII.  In
particular, the energy aperture as a function of position around the
ring is determined by tracking.  Starting at the beginning of the
lattice and working downstream, particles are tracked starting from
the exit of each selected element.  The betatron coordinates are
initially zero (or very small), while the momentum deviation is
gradually increased until loss of the particle is observed.  This
defines the momentum aperture at that location.

In {\tt elegant} version 19.0 and later, the algorithm is as follows.  For simplicity in
wording, we'll assume the momentum deviations are positive values,
although the method is applied separately for negative values as well:
\begin{enumerate}
\item Start with $\delta=0$, i.e., zero momentum offset.
\item Track a particle to see if it gets lost.  If so, proceed to step 4.
\item Increase $\delta$ by step size $\Delta\delta$ and return to step 2.
\item If no splitting steps remain, proceed to the next step.  Otherwise:
\begin{enumerate}
\item Change $\delta$ to $delta_s - s_b\Delta\delta$., where $\delta_s$ is
 the largest $\delta$ for which the particle survived, and $s_b$ is the
 \verb|steps_back| parameter.
\item Divide the step size by \verb|split_step_divisor| to get a new step size  $\Delta\delta$.
\item Set $\delta = \delta + \Delta\delta$.
\item Decrement the ``splits remaining'' counter by 1.
\item Continue from step 2.
\end{enumerate}
\item Stop.  The momentum aperture is $\delta_s$
\end{enumerate}

This command can be used for both rings and transport lines.  For
rings it is most appropriate to have an rf cavity (i.e., an {\tt RFCA}
element) in the lattice.  One should also include radiation loss using
either of two methods:
\begin{enumerate}
\item {\tt SREFFECTS} element, with {\tt QEXCITATION=0}.  To set up this element more easily, one
 can include a \verb|twiss_output| command with \verb|radiation_integrals=1|.
\item Use {\tt CSBEND} and {\tt KQUAD} elements with \verb|SYNCH_RAD=1| and \verb|ISR=0|.
\end{enumerate}
When including radiation loss, one must be certain to set the phase of the rf cavity
correctly.  It is also a good idea to track for several synchrotron oscillation periods.

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|optimize|}\end{center}
\end{latexonly}
\subsection{optimize \label{subsec:optimize}}

\begin{itemize}
\item type: major action command.
\item function: perform optimization.
\item note: on UNIX systems, the user may press Control-C to force
\verb|elegant| to terminate optimization and proceed as if
optimization had converged.  (To genuinely terminate the run during
optimization press Control-C twice.) This is very useful if one wants
to get a look at the partially optimized result.  If one uses parameter
saving (\verb|run_setup|) or \verb|save_lattice| one can make a new
run that starts from the optimized result.

\end{itemize}

\begin{verbatim}
&optimize
     long summarize_setup = 0;
&end
\end{verbatim}

\begin{itemize}

\item \verb|summarize_setup| --- A flag indicating, if set, that a
summary of the optimization parameters should be printed.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|optimization_constraint|}\end{center}
\end{latexonly}
\subsection{optimization\_constraint \label{subsec:optimizationconstraint}}

\begin{itemize}
\item type: setup command.
\item function: define a constraint for optimization.
\item N.B.: This command is {\em disparaged}. It is {\em far} better to put constraints
	into the optimization equation (via the \verb|equation| parameter of
	\verb|optimization_setup| or via \verb|optimization_term|).  The reason
	is that the hard constraints imposed by \verb|optimization_constraint|
	may make it more difficult for the optimizer to converge.  See the discussion of the
        \verb|selt| and \verb|segt| macros in the manual entry to \verb|optimization_setup|.
\end{itemize}

\begin{verbatim}
&optimization_constraint
    STRING quantity = NULL;
    double lower = 0;
    double upper = 0;
&end
\end{verbatim}

\begin{itemize}

\item \verb|quantity| --- The quantity to be constrained, given as the
name of a quantity from among the optimization variables, optimization
covariables, and the ``final'' parameters (see the entry for
\verb|run_setup| for the last of these).  The optimization
(co)variables are referred to as
\verb|<element-name>.<parameter-name>|, in all capital letters.  Other
quantities, such as Twiss parameters or anything else but what is
listed just above, are not recognized.  Expressions involving multiple
quantities are not supported.

\item \verb|lower|, \verb|upper| --- The lower and upper limits
allowed for the expression.

\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|optimization_covariable|}\end{center}
\end{latexonly}
\subsection{optimization\_covariable \label{subsec:optimizationcovariable}}

\begin{itemize}
\item type: setup command.
\item function: define an element parameter to be varied as a function of optimization parameters.
\item N.B.: It is not possible to optimize an element if the element name starts with one of the following
characters: 
\verb|0|, \verb|1|, \verb|2|, \verb|3|, \verb|4|, \verb|5|, \verb|6|, \verb|7|, \verb|8|,
\verb|9|, \verb|.|, \verb|+|, or \verb|-|.  The reason is that {\tt elegant} will attempt to 
make an SDDS parameter name containing the element name, and these characters are disallowed
at the beginning of such a name.
\end{itemize}

\begin{verbatim}
&optimization_covariable
    STRING name = NULL;
    STRING item = NULL;
    STRING equation = NULL;
    long disable = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|name| --- The name of the element.
\item \verb|item| --- The parameter of the element to be changed.
\item \verb|equation| --- An {\tt rpn} equation for the value of the parameter in terms of the
values of any parameters of any optimization variable.  These latter appear in the equation in the
form \verb|<element-name>.<parameter-name>|, in all capital letters.  The original values of all
variables and covariable may be accessed via names like \verb|<element-name>.<parameter-name>0|.
\item \verb|disable| --- If nonzero, the covariable is ignored.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|optimization_setup|}\end{center}
\end{latexonly}
\subsection{optimization\_setup \label{subsec:optimizationsetup}}

\begin{itemize}
\item type: setup command.
\item function: define overall optimization parameters and methods.
\end{itemize}

\begin{verbatim}
&optimization_setup
    STRING equation = NULL;
    STRING mode = "minimize";
    STRING method = "simplex";
    double tolerance = -0.01;
    double target = 0;
    long soft_failure = 1;
    long n_passes = 2;
    long n_evaluations = 500; 
    long n_restarts = 0;
    long matrix_order = 1;
    STRING log_file = NULL;
    STRING term_log_file = NULL;
    long output_sparsing_factor = 0;
    long balance_terms = 0;
    double restart_worst_term_factor = 1;
    long restart_worst_terms = 1;
    long verbose = 1;
    long balance_terms = 0;
    double simplex_divisor = 3;
    double simplex_pass_range_factor = 1;
    long include_simplex_1d_scans = 1;
    long start_from_simplex_vertex1 = 0;
    long restart_random_numbers = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|equation| --- An {\tt rpn} equation for the optimization
function, expressed in terms of any parameters of any optimization
variables, the ``final'' parameters of the beam (as recorded in the
\verb|final| output file available in the \verb|run_setup| namelist),
and selected quantities from Twiss parameter, tune shift with amplitude,
closed orbit, beam moments, driving terms, and other computations.
The optimization variables or covariables may appear in the equation
in the form \verb|<element-name>.<parameter-name>|, all in capital
letters.  In addition, initial values of variables and covariables
are available in the form \verb|<element-name>.<parameter-name>0|.

Data from MARK elements with {\tt FITPOINT=1} and from beam position
monitors with {\tt CO\_FITPOINT=1} may be used via symbols of the form
{\tt {\em elementName}\#{\em occurenceNum}.{\em parameterName}}.  See the
documentation for the {\tt MARK}, {\tt MONI}, {\tt HMON}, and {\tt
VMON} elements for detailed discussion and listing.

If response matrix calculation is requested, response matrix values
are available in variables with names {\em Plane}{\tt R\_}{\em
bpmName}\verb|#|{\em occurence}{\tt \_}{\em corrName}\verb|#|{\em occurence}{\tt
.}{\em corrParam}, where {\em Plane} is {\tt H} (horizontal) or {\tt
V} (vertical) and {\em corrParam} is the parameter of the corrector
used for changing the orbit (e.g., {\tt HKICK} or {\tt VKICK} for a
{\tt KICKER} element).

If cross-plane response matrix calculation is requested, response matrix values
are available in variables with names {\em BpmPlane}{\em CorrPlane}{\tt R\_}{\em
bpmName}\verb|#|{\em occurence}{\tt \_}{\em corrName}\verb|#|{\em occurence}{\tt
.}{\em corrParam}, where {\em BpmPlane} and {\em CorrPlane} are  {\tt H} (horizontal) or {\tt
V} (vertical) and {\em corrParam} is the parameter of the corrector
used for changing the orbit (e.g., {\tt HKICK} or {\tt VKICK} for a
{\tt KICKER} element).

Many quantities are made available for optimization if \verb|twiss_output| command is given
with \verb|output_at_each_step=1|:
\begin{itemize} 
\item Final Twiss parameters, e.g., \verb|betax|, \verb|alphax|, \verb|etax|.  The names
are the same as the column names in the twiss output file.
\item Statistics of Twiss parameters in the form \verb|<statistic>.<parameter-name>|,
where \verb|<statistic>| is either \verb|min| or \verb|max|.
\item Tunes and chromaticities via symbols \verb|nux|, \verb|dnux/dp|, (and corresponding
symbols for y).
\item First- and second-order momentum compaction factors via symbols \verb|alphac| and \verb|alphac2|.  
\item If radiation integral computation is requested,  one may use \verb|ex0| and \verb|Sdelta0| for
the equilibrium emittance and momentum spread, plus \verb|J<plane>|
and \verb|tau<plane>| for the damping partition and damping time,
where \verb|<plane>| is \verb|x|, \verb|y|, or \verb|delta|.  One may also use
\verb|I1| through \verb|I5| for the individual radiation integrals.
\item If \verb|compute_driving_terms=1|, then the quantities
{\tt h11001}, {\tt h00111}, {\tt h20001}, {\tt h00201}, {\tt h10002}, {\tt h21000}, {\tt h30000}, {\tt h10110}, {\tt h10020},
{\tt h10200}, {\tt h22000}, {\tt h11110}, {\tt h00220}, {\tt h31000}, {\tt h40000}, {\tt h20110}, {\tt h11200}, {\tt h20020},
{\tt h20200}, {\tt h00310}, {\tt h00400}, {\tt dnux/dJx}, {\tt dnux/dJy},  and {\tt dnuy/dJy} 
may be used.  Table \ref{tab:drivingTerms} explains the meaning of the terms.
\item The coupling integral and emittance ratio due to x-y coupling may
be accessed using the symbols \verb|couplingIntegral| and
\verb|emittanceRatio|.  See section 3.1.4.4 of \cite{HAPE}.
\item If higher-order chromaticity is requested, then one may use the
  symbols {\tt dnux/dp2}, {\tt dnux/dp3}, {\tt dnuy/dp2}, {\tt
    dnuy/dp3}, {\tt etax2} , {\tt etax3}, {\tt etay2} , {\tt etay3},
  {\tt nuxChromLower}, {\tt nuxChromUpper}, {\tt nuyChromLower}, and
  {\tt nuyChromUpper}.
\item If the \verb|tune_shift_with_amplitude| command was also given
  and one may use the symbols {\tt dnux/dAx}, {\tt dnux/dAy}, {\tt
    dnuy/dAx}, {\tt dnuy/dAy}, {\tt dnux/dAx2}, {\tt dnux/dAy2}, {\tt
    dnux/dAxAy}, {\tt dnuy/dAx2}, {\tt dnuy/dAy2}, {\tt dnuy/dAxAy},
  {\tt nuxTswaLower}, {\tt nuxTswaUpper}, {\tt nuyTswaLower}, and {\tt
    nuyTswaUpper}.

\end{itemize}

If the \verb|floor_coordinates| command was given, one may use
\verb|X|, \verb|Z|, and \verb|theta| to refer to the final values of
the floor coordinates.

If the \verb|sasefel| command was given, one may use variables of
the form \verb|SASE.<property>|, where \verb|<property>| is one
of \verb|gainLength|, \verb|saturationLength|, 
\verb|saturationPower|, or \verb|lightWavelength|.

Finally, one may use any of the names from the ``final'' output file
(see \verb|run_setup|), e.g., \verb|Sx| (x beamsize) or \verb|eny| (y
normalized emittance).  These refer to tracked properties of the beam.

The equation may be left blank, in which case the user must give one
or more \verb|optimization_term| commands.  These use the same
symbols, of course.

There are several {\tt rpn} functions that are useful in constructing
a good optimization equation.  These are ``soft-edge'' greater-than, less-than,
and not-equal functions, which have the names {\tt segt}, {\tt selt}, and
{\tt sene}, respectively.  The usage is as follows:
\begin{itemize}
\item {\em V1} {\em V2} {\em T} {\tt segt}.  Returns a
 nonzero value if and only if value {\em V1} is greater than {\em V2}.  The 
 returned value is $((V_1-V_2)/T)^2$.  Typically used to constraint a quantity from
 above.  E.g., to limit the maximum horizontal beta function to 10m with
 a tolerance of $T=0.1m$, one would use \verb|max.betax 10 .1 segt|.
\item {\em V1} {\em V2} {\em T} {\tt selt}.  Returns a
 nonzero value if and only if value {\em V1} is less than value {\em V2}.  The 
 returned value is $((V_1-V_2)/T)^2$.    Typically used to constrain a value from
 below.  E.g., to limit a beta function to greater than 3 m with a tolerance of 0.1 m,
 one would use \verb|betax 3 .1 selt|.
\item {\em V1} {\em V2} {\em T} {\tt sene}.  Returns a nonzero value
 if and only if {\em V1} and {\em V2} differ by more than {\em tol}.  If
 $V_1>V_2$, returns $((V_1-(V_2+T))/T)^2$.  If $V_2>V_1$, returns
 $((V_2-(V_1+T))/T)^2$.
\end{itemize}
\item \verb|mode| --- May be either ``minimize'' or ``maximize''.

\item \verb|method| --- May be one of ``simplex'', ``grid'', ``powell'', ``randomwalk'', ``randomsample'', or ``sample''.  Recommended methods are ``simplex'' and ``randomwalk''. The latter is very useful when the lattice is unstable or nearly so.

\item \verb|tolerance| --- The convergence criterion for the optimization, with a negative value indicating
a fractional criterion.
\item \verb|target| --- The value which, if reached, results in immediate termination of the optimization,
whether it has converged or not.
\item \verb|soft_failure| --- A flag indicating, if set, that failure of an optimization pass should not
result in termination of the optimization.

\item \verb|n_evaluations| --- The number of allowed evaluations of
the optimization function.  If simplex optimization is used, this is
the number of allowed evaluations per pass.

\item \verb|n_passes| --- The number of optimization passes made to
achieve convergence (``simplex'' only).  A pass ends (roughly) when
the number of evaluations is completed or the function doesn't change
within the tolerance.  A new pass involves starting the optimization
again using step sizes determined from the range of the simplex and
the factor \verb|simplex_pass_factor|.

\item \verb|n_restarts| --- The number of complete restarts of the
optimization (simplex only).  This is an additional loop around the
\verb|n_passes| loop.  The difference is that a restart involves using
the optimized result but the original step sizes.  It is highly
recommended that this feature be used if convergence problems are seen.

\item \verb|restart_worst_term_factor|, \verb|restart_worst_terms| --- Often
when there are convergence problems, it is because a few terms are causing 
difficulty.  Convergence can often be obtained by {\em increasing} the weighting
of these terms.  If  \verb|restart_worst_term_factor| is positive, then \verb|elegant|
will multiply the weight of the \verb|restart_worst_terms| largest terms by this
factor at the beginning of a restart.

\item \verb|matrix_order| --- Specifies the highest order of matrix elements that
should be available for fitting.  Elements up to third order are available for
the terminal point of the beamline, and up to secod order for interior fit points.
Names for first-, second-, and third-order elements are of the form
{\tt R}{\em ij}, {\tt T}{\em ijk}, and {\tt U}{\em ijkl}.
\item \verb|log_file| --- A file to which progress reports will be written as optimization proceeds.
For SDDS data, use the \verb|final| output file from the \verb|run_setup| namelist.

\item \verb|term_log_file| --- This names a file to which the
  values of the optimization terms are written at the completion of optimization, which can be convenient when large numbers
  of terms are used.  For example, by using \verb|sddssort| one could find which terms are contributing most to the
  penalty value.

\item \verb|output_sparsing_factor| --- If set to a value larger than 0, results in
sparsing of output to the ``final'' file (see \verb|run_setup|). This can make
a significant difference in the optimization speed.

\item \verb|balance_terms| --- If nonzero, then all terms of the optimization expression have
 their weights adjusted so they make equal contributions to the penalty function.  This can
 help prevent optimization of a single term at the expense of others.  It is performed only 
 for the initial value of the optimization function.

\item \verb|simplex_divisor| --- The factor by which simplex step sizes are changed as the 
 optimization algorithm searches for a valid initial simplex.

\item \verb|simplex_pass_range_factor| --- When starting a new pass, the simplex optimizer takes
 the range over the previous simplex of each variable times this factor
 as the starting step size for that variable.  This can be useful if the optimization brings
 the system close to an instability.  In such a case, the simplex routine may have trouble
 constructing an initial simplex if the range of the variables is large. Setting this control
 to a value less than 1 may help.
 
\item \verb|include_simplex_1d_scans| --- If nonzero, optimizer performs single-variable scans prior to 
 starting simplex optimization.  This is usually a good idea, but in some cases it will cause problems.
 For example, if your design is on the edge of being unstable, you may get some many errors from the
 initial steps that the single-variable optimizer can't continue.  Disabling the
 single-variable scans will sometimes solve this.

\item \verb|start_from_simplex_vertex1| --- If nonzero, optimizer uses the initial simplex vertex as the
 starting point for each new 1d scan.  Otherwise, it uses the result of the previous scan.

\item \verb|restart_random_numbers| --- If nonzero, the random number generators used by {\tt elegant} are
 reset for each evaluation of the optimization function.  This is valuable if one is optimizing tracking
 results that involve random processes (e.g., ISR or scattering).

\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|parallel_optimization_setup|}\end{center}
\end{latexonly}
\subsection{parallel\_optimization\_setup \label{subsec:paralleloptimizationsetup}}

\begin{itemize}
\item type: setup command (for {\tt Pelegant} only).
\item function: define overall parallel optimization parameters and methods.
\item N.B.: In addition to the optimization parameters used in the optimization\_setup command, 	    
      several new parameters are added for parallel optimization. User should replace 
      optimization\_setup with parallel\_optimization\_setup and append necessary parameters. 
\end{itemize}

\begin{verbatim}
&parallel_optimization_setup
    STRING method = "simplex";
    double random_factor = 1
    long n_iterations = 10000;
    long max_no_change = 10000;
    long population_size = 100;
    STRING population_log = NULL;
    long print_all_individuals = 0;
    long output_sparsing_factor = 1;
&end
\end{verbatim}

\begin{itemize}
\item \verb|method| --- May be one of "genetic", "hybridsimplex" or "swarm". If the default "simplex" method is chosen, all the processors will do the same optimization as the serial version and then track in parallel. All algorithms can be used for global optimization. "swarm" is recommended when there is sufficient computation resource available, so it can reach the optimization target fast. "hybridsimplex" is recommended when the initial point is close to the optimal result. "genetic" can be chosen for a global optimizer with a random start point (0 should be avoided for any initial coordinate). 

\item \verb|random_factor| --- The factor to scale the step size for both parallel swarm and genetic methods.

\item \verb|n_restarts| --- For the parallel "hybridsimplex" method, this number should be set larger than 1, so the the best result across all processors can be used for the next restart. The parameter is not used for the swarm method.

\item \verb|n_iterations| --- The maximal number of generations/iterations for the parallel genetic and particle swarm optimization. 

\item \verb|population_size| --- The number of individuals to be generated for each generation/iteration for the swarm and genetic method. For the hybridsimplex method, the number of individuals is equal to the number of processors used.

\item \verb|max_no_change| --- The maximal number of generations in which no change in the best evaluation is allowed before the genetic method stops (genetic method only).

\item \verb|n_evaluations| --- This is not used as a stop condition in the genetic optimization. The n\_iterations or max\_no\_change can be used instead. For the hybridsimplex method, this is the number of allowed evaluations per restart. 

\item \verb|population_log| --- An SDDS file to which the best individual in a population can be written after each iteration as optimization proceeds. Recommended value: ``\%s.pop''. For the parallel genetic method, user can choose to print out all the individuals (See print\_all\_individuals).

\item \verb|print_all_individuals| --- If nonzero, all the strings in a population will be recorded in the population\_log file. This is supported for the genetic method only.

\item \verb|output_sparsing_factor| --- For genetic optimization, this is used to set the frequency of printing strings in the log file with the number of generations as the interval.

\end{itemize}

Note:
\begin{itemize}
\item Genetic optimization in {\tt Pelegant} terminates when at least one of the stopping rules specified has been met. 
The two stopping rules are: 

\begin{itemize}
\item generation limit (n\_iterations) exceeded
\item no change in the best solution found in a given number of generations. 
The default is to stop when the generation limit (10000 is the default value) is reached. While the max\_no\_change is more favorite to use, as it will stop until the result can not be improved after a certain number of iterations (10000 is the default value). The n\_iterations can be set 
to a very large number to use this rule as the stop condition alone.
\end{itemize}

\item step size control -- The mutation step size in the genetic optimization is selected from a Gaussian distribution with mean 0 and standard deviation step\_size, where step\_size is provided by user. All the dimensions will use the same standard deviation for an iteration. The step\_size of the first dimension provided by user will be used as the original step size for all the dimensions. The step size will be reduced by the golden ratio (1.618) if the best value is unchanged after every 3000 iterations. After every 3000 iterations since the last time the step size is reduced, the step size will be increased by the golden ratio.

\item As the genetic optimization implementation in {\tt Pelegant} internally updates individuals with a relative change of the current value for a variable, 0 should be avoided to use as an initial value.

\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|optimization_term|}\end{center}
\end{latexonly}
\subsection{optimization\_term \label{subsec:optimizationterm}}

\begin{itemize}
\item type: setup command.

\item function: define optimization equation via individual terms

\end{itemize}

\begin{verbatim}
&optimization_term
    STRING term = NULL;
    double weight = 1.0;
    STRING field_string = NULL;
    long field_initial_value = 0;
    long field_final_value = 0;
    long field_interval = 1;
    STRING input_file = NULL;
    STRING input_column = NULL;
    long verbose = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|term| --- An {\tt rpn} expression giving one term to be optimized.
If more than one \verb|optimization_term| command is given, then the terms are
added.   The advantage of using this command over giving an equation via
\verb|optimization_setup| is that {\tt elegant} will report the value of
each term as it performs the optimization (if a \verb|log_file| is given to
\verb|optimization_setup|).  This permits determination of
which terms are causing problems for the optimization.

Please see the entry for {\tt equation} under {\tt optimization\_setup} for
details on designing optimization terms.

\item \verb|weight| --- The weight to assign to this term.  If zero, the term
        is ignored.


\item \verb|field_string|, \verb|field_initial_value|, \verb|field_final_value|, \verb|field_interval| --- 
  These parameters are used to perform substitution of a series of values into the string given by
  \verb|term|.  This can be used to make an identical constraint at a number of instances
  of the same marker.  For example, to constraint \verb|Cx| to zero at instances 1, 3, 5, ..., 39,
  of marker \verb|M1|, one could use
\begin{verbatim}
&optimization_term
  term = "M1#@.Cx sqr", 
  field_string = @, 
  field_initial_value = 1, field_final_value = 39, field_interval = 2
&end
\end{verbatim}

\item \verb|input_file|, \verb|input_column| --- If given, \verb|input_file| is taken as the name of an SDDS file,
  which is expected to have a string column named by \verb|input_column|.  Each row of the column is taken as
  a separate optimization term.

\item \verb|verbose| --- If nonzero, optimization terms are echoed to the terminal as they are created or read
  from the input file.

\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|optimization_variable|}\end{center}
\end{latexonly}
\subsection{optimization\_variable \label{subsec:optimizationvariable}}

\begin{itemize}
\item type: setup command.
\item function: defines a parameter of an element to be used in optimization.
\item N.B.: It is not possible to optimize an element if the element name starts with one of the following
characters: 
\verb|0|, \verb|1|, \verb|2|, \verb|3|, \verb|4|, \verb|5|, \verb|6|, \verb|7|, \verb|8|,
\verb|9|, \verb|.|, \verb|+|, or \verb|-|.  The reason is that {\tt elegant} will attempt to 
make an SDDS parameter name containing the element name, and these characters are disallowed
at the beginning of such a name.
\end{itemize}

\begin{verbatim}
&optimization_variable
    STRING name = NULL;
    STRING item = NULL;
    double lower_limit = 0;
    double upper_limit = 0;
    double step_size = 1;
    long disable = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|name| --- The name of the element.
\item \verb|item| --- The parameter of the element to be varied.
\item \verb|lower_limit|, \verb|upper_limit| --- The lower and upper limits allowed for the parameter.  If these are
equal, the range of the parameter is unlimited.
\item \verb|step_size| --- The initial step size (``simplex'' optimization ) or the grid size in this dimension (``grid'' or ``sample'' optimization).
\item \verb|disable| --- If nonzero, the covariable is ignored.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|print_dictionary|}\end{center}
\end{latexonly}
\subsection{print\_dictionary \label{subsec:printdictionary}}

\begin{itemize}
\item type: action command.
\item function: print dictionary of supported accelerator elements.
\end{itemize}

\begin{verbatim}
&print_dictionary
    STRING filename = NULL;
    long SDDS_form = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|filename| --- The name of a file to which the dictionary will be written.  By default, the 
  output is in \LaTeX format.
\item \verb|SDDS_form| --- If non-zero, then the output is in  SDDS format.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|ramp_elements|}\end{center}
\end{latexonly}
\subsection{ramp\_elements\label{subsec:rampelements}}

\begin{itemize}
\item type: setup command.
\item function: define parameters for time-dependent ramping of elements
\item N.B.: this feature is somewhat experimental.  Please use with caution and report any problems on the forum.
\end{itemize}

\begin{verbatim}
&modulate_elements
    STRING name = NULL;
    STRING item = NULL;
    STRING type = NULL;
    long start_pass = 0;
    long end_pass = LONG_MAX;
    double start_value = 0;
    double end_value = 0;
    long differential = 1;
    long multiplicative = 0;
    long start_occurence = 0;
    long end_occurence = 0;
    double s_start = -1;
    double s_end = -1;
    STRING before = NULL;
    STRING after = NULL;
    long verbose = 0;
&end
\end{verbatim}

N.B.: This command will produce unpredictable results when used with
\verb|error_element|, \verb|alter_elements|, \verb|modulate_elements|, and
\verb|load_parameters| (except when \verb|change_defined_values=1|).
It should work properly with \verb|link_elements| in turn-by-turn mode
when the source element is ramped, but not when the target element
is ramped.

\begin{itemize}
\item \verb|name| --- A possibly-wildcard-containing string giving the names of the
        elements to modulate. If not specified, then one must specify \verb|type|.
\item \verb|item| --- The name of the parameter to modulate.
\item \verb|type| --- A possibly-wildcard-containing string giving the names of element
        {\em types} to modulate.  May be specified with \verb|name| or by itself.
\item \verb|start_pass|, \verb|end_pass| --- The starting and ending pass, 
  $i_{\rm start}$ and $i_{\rm end}$ for the ramp.
 For passes less than \verb|start_pass|, the ramp value is \verb|start_value|.
 For passes greater than \verb|end_pass|, the ramp value is \verb|end_value|.
\item \verb|start_value|, \verb|end_value| --- The end-point values $S$ (start) and $E$ (end) of the ramp.
\item \verb|exponent| --- The exponent $p$ for the variation of values between the start and end
  of the ramp.  The ramp function $R(i)$ is 
\begin{equation}
  R(i) = S + (E-S)*\left(\frac{i-i_{\rm start}}{i_{\rm end}-i_{\rm start}}\right)^p.
\end{equation}
Note that $i=0$ on the first pass.
\item \verb|differential|, \verb|multiplicative| --- Determine how the amplitude function
  $A(t)$ is used to obtain the new value of the parameter.  There are four cases
  \begin{itemize}
    \item \verb|differential=1|, \verb|multiplicative=0|: $v(t) = v_0 + R(i)$ (default).
    \item \verb|differential=0|, \verb|multiplicative=0|: $v(t) = R(i)$.  
    \item \verb|differential=1|, \verb|multiplicative=1|: $v(t) = v_0 + v_0 R(i)$.  
    \item \verb|differential=0|, \verb|multiplicative=1|: $v(t) = v_0 R(i)$.  
  \end{itemize}
\item \verb|start_occurence|, \verb|end_occurence| --- If nonzero, these give the starting and
 ending occurrence numbers of elements that will be modulated. N.B.: if wildcards are used, occurrence
 number counting is for each set of identically-named elements separately, rather than for the sequence
 of matched elements.
\item \verb|s_start|, \verb|s_end| --- If non-negative, these give the gaving and ending position
 limits for the end-of-element locations of elements to be modulated.
\item \verb|after| --- The name of an element.  If given, the modulation is applied only to elements
 that follow the named element in the beamline.  
\item \verb|before| --- The name of an element.  If given, the modulation is applied only to elements
 that precede the named element in the beamline. 
\item \verb|verbose| --- If nonzero, information is printed to the standard output as changes are
        made.  Use for debugging only, since otherwise it may slow the simulation.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|replace_elements|}\end{center}
\end{latexonly}
\subsection{replace\_elements \label{subsec:replaceelements}}

\begin{itemize}
\item type: action command.
\item function: Replace old element with a newly defined element, or just 
   remove it from beamline. This is a convenient way to modify lattice in an elegant run.
\item notes: 
	The modified lattice can be saved through \verb|save_lattice|
   command. Be sure to use ``output\_seq = 1'' option in that command.  
\item warning:
   The element's occurrence is re-calculated after each usage of this command. If 
   you need to repeat this command for SAME named element several times, you have to re-calculate 
   it occurrence every time. For example, you want to remove Q1 at occurrence position 
   (1,3,5), and use 
   `replace\_elements'' twice. If in the first command you use ``occurence[0]=1,3'',
   then in the second command you have to use ``occurence[0]=3'', since after remove of
   (1,3) Q1s, the 5th Q1 now becoming 3rd Q1.
\end{itemize}

\begin{verbatim}
&replace_elements
        STRING name = NULL;
        STRING type = NULL;
        STRING exclude = NULL;
        long skip = 1;
        long disable = 0;
        STRING element_def = NULL;
        long total_occurrences = 0;
        long occurrence[100]={0};
&end
\end{verbatim}

\begin{itemize}
\item \verb|name| --- Possibly wild-card containing string specifying the
	name of the elements to be removed or replaced.
\item \verb|type| --- Possibly wild-card containing string specifying the
   type of the elements to be removed or replaced.
\item \verb|exclude| --- Possibly wild-card containing string specifying 
	the name of elements to be excluded from this command.
\item \verb|skip| --- The element is removed or replaced at every $n^{th}$ 
   specified location.
\item \verb|disable| --- If nonzero, the command is ignored.
\item \verb|element_def| --- If NULL, the specified elements are removed from
   the beamline. If not NULL, the specified elements are replaced with the new element
   defined here. The definition of the element should be just as it would be entered in 
   the lattice file.
\item \verb|total_occurrences|, \verb|occurrence| --- 
These parameters are used to replace or delete specified occurrences of 
the element \verb|name|.  \verb|total_occurrences| specifies how many elements to replace
or delete up to a maximum of 100, while the entries in the array \verb|occurrence| specify the occurrences
to replace or delete. If \verb|total_occurrences| is non-zero, then {\bf skip} must
be set to zero  and the {\bf name} must be the exact name (no wild-card matching). 
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|rpn_expression|}\end{center}
\end{latexonly}
\subsection{rpn\_expression \label{subsec:rpnexpression}}

\begin{itemize}
\item type: action/setup command.
\item function: pass an expression directly to the rpn submodule for execution.
\end{itemize}

\begin{verbatim}
&rpn_expression
    STRING expression = NULL;
&end
\end{verbatim}

\begin{itemize}
\item \verb|expression| --- An {\tt rpn} expression.  This expression is executed immediately and can be
used, for example, to read in {\tt rpn} commands from a file or store values in {\tt rpn} memories.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|rpn_load|}\end{center}
\end{latexonly}
\subsection{rpn\_load \label{subsec:rpnload}}

\begin{itemize}
\item type: action/setup command.
\item function: load data from SDDS file into RPN variables.
\end{itemize}

\begin{verbatim}
&rpn_load
    STRING tag = NULL;
    STRING filename = NULL;
    STRING match_column = NULL;
    STRING match_column_value = NULL;
    long matching_row_number = -1;
    STRING match_parameter = NULL;
    STRING match_parameter_value = NULL;
    long use_row = -1;
    long use_page = -1;
    long load_parameters = 0;
&end
\end{verbatim}

This command is used to facilitate multi-stage optimization runs by allowing convenient
loading of data from SDDS files into RPN variables.  For example, one may match the
final Twiss parameters of a lattice to the parameters stored in an SDDS file from
a different run.

\begin{itemize}

\item \verb|tag| --- Option string that will be pre-pended to the names of all the numerical columns 
 in the file in order to create RPN variable names.  E.g., if the input file was from the
 \verb|twiss_output| command and \verb|tag = tw1| was given, then RPN variables 
 \verb|tw1.betax|, \verb|tw1.alphax|, etc. would be used.  {\em N.B.: If the tag is blank, then nothing 
 is appended to the names from the file.  This can be dangerous since the names may conflict with
 the names of other variables!}

\item \verb|filename| --- The (incomplete) name of the SDDS file from which to read data.
    By default, data is taken from all columns from the last row of the last page of the file.
    This default behavior can be altered using one or more of the following parameters:
\begin{itemize}
    
\item \verb|match_column| --- The name of a string column to use in selecting the row from
 which data will be taken.

\item  \verb|match_column_value| --- The value that the column named by \verb|match_column| must
 have to be selected from the file.  By default, the last row with a matching value is used.

\item \verb|matching_row_number| --- If a nonnegative value is given, then the \verb|matching_row_number|$^{th}$
 matching row is selected (0 is the first row, 1 the second, etc).  Otherwise, the last match row is used.  Ignored if \verb|match_column| is not
 given.

\item \verb|match_parameter| --- The name of a string parameter to use in selecting the page
 from which data will be taken.  

\item \verb|match_parameter_value| --- The value that the parameter named by \verb|match_parameter| must
 have to be selected from the file.  By default, the last page with a matching value is used.

\item \verb|use_row| --- If nonnegative, specifies the row number to use, starting at 0 for the first row.
 Ignored if \verb|match_column| is given.

\item \verb|use_page| --- If nonnegative, specifies the page number to use, starting at 1 for the first page.
 Takes precedence over \verb|\match_parameter| if both are given.

\item \verb|load_parameters| --- If nonzero, specifies loading the SDDS parameter data rather than the column data.
\end{itemize}
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|run_control|}\end{center}
\end{latexonly}
\subsection{run\_control \label{subsec:runcontrol}}

\begin{itemize}
\item type: setup command.
\item function: set up the number of simulation steps and passes.
\end{itemize}

\begin{verbatim}
&run_control
    long n_steps = 1;
    double bunch_frequency = 0;
    long n_indices = 0;
    long n_passes = 1;
    long reset_rf_for_each_step = 1;
    long first_is_fiducial = 0;
    long restrict_fiducialization = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|n_steps| --- The number of separate repetitions of the action implied by the next action command.
If random errors are defined, this is also the number of separate error ensembles.
\item \verb|bunch_frequency| --- The frequency to use in calculating the time delay between repetitions.
\item \verb|n_indices| --- The number of looping indices for which to expect definitions in subsequent \verb|vary_element| commands.  If nonzero, then \verb|n_steps| is ignored.
\item \verb|n_passes| --- The number of passes to make through the beamline per repetition.
\item \verb|reset_rf_for_each_step| --- If nonzero, the rf phases are 
established anew for each bunch tracked.  Should be zero to simulate
phase and timing jitter. 
\item \verb|first_is_fiducial| --- If nonzero, the first bunch seen is taken
to establish the reference phases and momentum profile.  If zero, each bunch
is treated as a new fiducializing bunch.
\item \verb|restrict_fiducialization| --- If nonzero, then  momentum profile
fiducialization occurs only after elements that are intended
change the momentum, such as rf cavities.  If zero, then each element is
fiducialized to the average momentum of the beam.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|run_setup|}\end{center}
\end{latexonly}
\subsection{run\_setup \label{subsec:runsetup}}

\begin{itemize}
\item type: setup command.
\item function: set global parameters of the simulation and define primary input and output files.
\end{itemize}

\begin{verbatim}
&run_setup
    STRING lattice = NULL;
    STRING use_beamline = NULL;
    STRING rootname = NULL;
    STRING output = NULL;
    STRING centroid = NULL;
    STRING sigma = NULL;
    STRING final = NULL;
    STRING acceptance = NULL;
    STRING losses = NULL;
    STRING magnets = NULL;
    STRING semaphore_file = NULL;
    STRING parameters = NULL;
    long combine_bunch_statistics = 0;
    long wrap_around = 1;
    long final_pass = 0;
    long default_order = 2;
    long concat_order = 0;
    long print_statistics = 0;
    long random_number_seed = 987654321;
    long correction_iterations = 1;
    double p_central = 0.0;
    double p_central_mev = 0.0;
    long always_change_p0 = 0;
    STRING expand_for = NULL; 
    long tracking_updates = 1;
    long echo_lattice = 0;
    STRING search_path = NULL;
    long element_divisions = 0;
    long load_balancing_on = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|lattice| --- Name of the lattice definition file.
\item \verb|echo_lattice| --- If nonzero, the lattice input is echoed to the
        standard output as the lattice is parsed.  This can help detect certain
        problems with the lattice that cause \verb|elegant| to crash.
\item \verb|use_beamline| --- Name of the beamline to use.
\item \verb|rootname| --- Filename fragment used in forming complete names from incomplete filenames.  By default, 
the filename minus extension of the input file is used.
\item \verb|output| --- The (incomplete) name of an SDDS file into which final phase-space coordinates
will be written.  Recommended value: ``\%s.out''.
\item \verb|centroid| --- The (incomplete) name of an SDDS file into which beam centroids as a function
of s will be written.   Recommended value: ``\%s.cen''.
\item \verb|sigma| --- The (incomplete) name of an SDDS file into
which the beam sigma matrix as a function of z will be written.
Recommended value: ``\%s.sig''.  N.B.: confusion sometimes occurs about some of the quantities related to
the {\tt s} coordinate in this file.  Please see Section \ref{sec:longitCoord} above.
\item \verb|final| --- The (incomplete) name of an SDDS file into
which final beam and transport parameters will be written. Recommended
value: ``\%s.fin''.   N.B.: confusion sometimes occurs about some of the quantities related to
the {\tt s} coordinate in this file.  Please see Section \ref{sec:longitCoord} above.
\item \verb|acceptance| --- The (incomplete) name of an SDDS file into
which the initial coordinates of transmitted particles will be
written.  Recommended value: ``\%s.acc''.
\item \verb|losses| --- The (incomplete) name of an SDDS file into
which information on lost particles will be written. Recommended
value: ``\%s.lost''.
\item \verb|magnets| --- The (incomplete) name of an SDDS file into
which a magnet layout representation will be written.  Recommended
value: ``\%s.mag''.
\item \verb|semaphore_file| --- The (incomplete) name of file that
will be created just before exit from the program, but only if no
errors occured.  If the file exists, it is deleted.  This file can be
used to record the fact that the run completed without error.
\item \verb|parameters| --- The (incomplete) name of an SDDS file into
which parameters of accelerator elements are written.
N.B.: this file does not contain any non-numerical parameters of the lattice.
Hence, it is not a complete description of the settings of the lattice.
\item \verb|combine_bunch_statistics| --- A flag indicating whether to
combine statistical information for all simulation steps.  If
non-zero, then the \verb|sigma| and \verb|centroid| data will be
combined over all simulation steps.
\item \verb|wrap_around| --- A flag indicating whether the s
 coordinate should wrap-around or increase monotonically in multipass
 simulations.  If zero, then the centroid and sigma data is computed for
 each turn with the s coordinate increasing continuously.
\item \verb|final_pass| --- A flag indicating whether the centroid and
 sigma output should be computed only from the data from the final pass.
 By default, the statistics include data from all passes.
\item \verb|default_order| --- The default order of transfer matrices
used for elements having matrices.
\item \verb|concat_order| --- If non-zero, the order of matrix
concatenation used.
\item \verb|print_statistics| --- A flag indicating whether to print
information as each element is tracked.
\item \verb|random_number_seed| --- A seed for the random number generators.  If zero, a seed will be generated from the system clock.
\item \verb|correction_iterations| --- Number of iterations of tune and chromaticity correction.
\item \verb|p_central| --- Central momentum of the beamline, about which expansions are done.
        This is $\beta\gamma$.
\item \verb|p_central_mev| --- Central momentum of the beamline in
MeV/c, about which expansions are done.  Ignored if \verb|p_central| is nonzero.
\item \verb|always_change_p0| --- If nonzero, then {\tt elegant} will match the reference momentum to
  the beam momentum after each element.  For example, in a beamline with radiation losses, one might
  want to adjust downstream magnets to match the energy of the incoming beam.
\item \verb|expand_for| --- Name of an SDDS file containing particle information, from which the central
momentum will be set.  The file contents are the same as required for {\tt elegant} input with the \verb|sdds_beam| namelist.
\item \verb|tracking_updates| --- A flag indicating whether to print summary information about
tracking.
\item \verb|search_path| --- Specify a list of pathnames in which to look for input files,
 including lattice files, wakefield input, particle input, etc.  This allows storing common
 input files in a convenient location without having to put the location into every filename.
\item \verb|element_divisions| --- Specify how many pieces to split elements into.  Only 
 certain elements (basically, those with a matrix) are split.  Results in creation of 
 \verb|element_divisions| new elements having the same name as each split element.
\item \verb|load_balancing_on| --- If non-zero, load-balancing is performed for parallel mode.
 This can result in non-deterministic results if the load-balancing is different on two
 otherwise identical runs.  Load-balancing variations may occur in heterogeneous clusters,
 clusters with multiple users, or for other reasons.  In such situations, turning off 
 load balancing can be useful if, for example, one is performing parameter scans and
 wishes to eliminate spurious sources of variation.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|sasefel|}\end{center}
\end{latexonly}
\subsection{sasefel \label{subsec:sasefel}}

\begin{itemize}
\item type: setup/action command.
\item function: set parameters for computation of SASE FEL gain and other properties.
\end{itemize}

\begin{verbatim}
&sasefel
    STRING output = NULL;
    STRING model = "Ming Xie";
    double beta = 0;
    double undulator_K = 3.1;
    double undulator_period = 0.033;
    double slice_fraction = 0.0;
    long n_slices = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|output| --- The (incomplete) filename of an SDDS file to which output will be
written.
\item \verb|model| --- The name of the FEL model used.  At present, only one model is
supported; the ``Ming-Xie'' model is based on the simple parametrization M. Xie\cite{MingXie}.
\item \verb|beta| --- The value of the beta function, in meters.
\item \verb|undulator_K| --- The K parameter of the undulator.
\item \verb|undulator_period| --- The undulator period, in meters.
\item \verb|slice_fraction|, \verb|n_slices| --- The fraction of beam beam contained by each analysis slice
        and the number of such slices.
        By default, no slice analysis is done.  Instead, the beam is analyzed only as a whole.
        If \verb|slice_fraction|*\verb|n_slices| is less than 1, then the slice analysis
        is centered on the median of the time distribution.  E.g., if \verb|n_slices|=1 and
        \verb|slice_fraction|=0.1, then the central 10\% of the beam would be analyzed.
        More typically, one gives values such that \verb|slice_fraction|*\verb|n_slices| is
        equal to 1, so that every part of the beam is analyzed.  There are separate values in
        the output file for each slice, plus the whole-beam and slice-averaged results.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|save_lattice|}\end{center}
\end{latexonly}
\subsection{save\_lattice \label{subsec:savelattice}}

\begin{itemize}
\item type: action command.
\item function: save the current accelerator element and beamline definitions.
\end{itemize}

\begin{verbatim}
&save_lattice
    STRING filename = NULL;
    long output_seq = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|filename| --- The (incomplete) name of a file to which the element and beamline definitions
will be written.  Recommended value: ``\%s.new''.
\item \verb|output_seq| --- If non-zero, the lattice will be saved as a single beamline sequence.
Elements used for the beamline are re-arranged according to their type. Note: 
sub-beamline definitions in the original lattice file will be destroyed from the output file.
This feature is intended to be used 
together with \verb|insert_elements| and \verb|replace_elements|. 
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|sdds_beam|}\end{center}
\end{latexonly}
\subsection{sdds\_beam \label{subsec:sddsbeam}}

\begin{itemize}
\item type: setup command.
\item function: set up for tracking and histogram analyzing of particle coordinates stored in an SDDS file.
\end{itemize}

\begin{verbatim}
&sdds_beam
    STRING input = NULL;
    STRING iput_list = NULL;
    STRING input_type = "elegant";
    long n_particles_per_ring = 0;
    STRING selection_parameter = NULL;
    STRING selection_string = NULL;
    long one_random_bunch = 0;
    long reuse_bunch = 0;
    long prebunched = 0;
    long sample_interval = 1;
    long n_tables_to_skip = 0;
    long center_transversely = 0;
    long center_arrival_time = 0;
    double sample_fraction = 1;
    double p_lower = 0.0;
    double p_upper = 0.0;
    long save_initial_coordinates = 1;
    long reverse_t_sign = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|input| --- Name of an  SDDS file containing coordinates of input particles.
\item \verb|input_type| --- May be ``elegant'' or ``spiffe'', indicating the name of the
program that wrote the input file.  The expected data quantities for the different types are:
\begin{itemize}
\item {\tt elegant}: ${\rm (x, xp, y, yp, t, p)}$, where x and y are
in meters, ${\rm xp=x^\prime}$ and ${\rm xp=y^\prime}$ are
dimensionless, t is in seconds, and ${\rm p=\beta\gamma}$ is the
dimensionless momentum. If this file is to be generated by the user,
the expected units string in the column definitions should be ``m'',
``s'', and ``m\$be\$nc'' for meters, seconds and the dimensionless
momentum, respectively.

\item {\tt spiffe}: ${\rm (r, z, pr, pz, pphi, t)}$, where r and z are
in meters, ${\rm pr=\beta_r \gamma}$, ${\rm pz = \beta_z \gamma}$,
${\rm p_\phi = \omega r \gamma/c}$, and t is in seconds. If this file
is to be generated by the user use the units strings described above.
\end{itemize}

\item \verb|n_particles_per_ring| --- For {\tt spiffe} data, gives the number of particles to
generate for each ring of charge.
\item \verb|selection_parameter| --- The name of a parameter in the SDDS file to be used for selection
of pages of data.
\item \verb|selection_string| --- The value of the
\verb|selection_parameter| selection parameter required for a page to
be used.  E.g., if one has a file from the {\tt shower} program
containing positrons, electrons, and photons, one might want to select
only the positrons.
\item \verb|one_random_bunch| --- A flag indicating whether, for {\tt spiffe} data, a new random
distribution should be calculated for each step of the simulation.
\item \verb|reuse_bunch| --- A flag indicating whether to use the bunch again or not.  If set, then the first bunch in the
file is used repeatedly for as many tracking steps as requested.  Otherwise, each bunch is used only once and the number of
steps is limited to the number of bunches (e.g., the number of pages in the file when \verb|prebunched=0|).
\item \verb|prebunched| --- A flag indicating, if zero, that the entire file is one ``bunch,'' and otherwise that each page in the file is a different bunch.
\item \verb|sample_interval| --- If non-zero, only every \verb|sample_interval|$^{\rm th}$ particle is used.
\item \verb|n_tables_to_skip| --- Number of SDDS pages to skip at the beginning of the file.
\item \verb|center_transversely| --- If non-zero, the transverse centroids of the distribution are made to be zero.
\item \verb|center_arrival_time| --- If non-zero, the mean arrival time of particles at the start of the
accelerator is set to zero.
\item \verb|sample_fraction| --- If non-unity, the randomly selected fraction of the distribution to use.
\item \verb|p_lower|, \verb|p_upper| --- If different, the lower and upper limit on ${\rm \beta\gamma}$ of particles to use.
\item \verb|save_initial_coordinates| --- A flag that, if set, results in saving initial coordinates
of tracked particles in memory.  This is the default behavior.  If unset, the initial coordinates
are not saved, but are reread from disk each time they are needed.  This is more memory efficient
and is useful for tracking very large numbers of particles.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|semaphores|}\end{center}
\end{latexonly}
\subsection{semaphores \label{subsec:semaphores}}

\begin{itemize}
\item type: setup command.
\item function: set up names for semaphore files, which are used to mark the
        start and end of program execution.
\end{itemize}

\begin{verbatim}
&semaphores
        STRING started = ``%s.started'';
        STRING done    = ``%s.done'';
        STRING failed  = ``%s.failed'';
&end
\end{verbatim}

\begin{itemize}
\item {\tt started} --- Gives the (incomplete) filename of a file to create when a valid
        {\tt run\_setup} command is given.
\item {\tt done} --- Gives the (incomplete) filename of a file to create when the program
        exits without error.  If the file exists, it is deleted when a valid {\tt run\_setup}
        command is given.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|slice_analysis|}\end{center}
\end{latexonly}
\subsection{slice\_analysis \label{subsec:sliceanalysis}}

\begin{itemize}
\item type: setup command.
\item function: set parameters for slice analysis of the beam along a
	beamline.  Also, results in placing the final slice analysis
        (at the end of the beamline) in symbols for use in optimization
        equations.  The names of the symbols are the same as the names
        of the columns in the output file.
\end{itemize}

\begin{verbatim}
&slice_analysis
STRING output = NULL;
long n_slices = 0;
double s_start = 0;
double s_end = 1e300;
long final_values_only = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|output| --- The (incomplete) filename of the output file.
	Recommended value is ``\%s.slan''.
\item \verb|n_slices| --- Number of slices to use.
\item \verb|s_start|, \verb|s_end| --- Position in beamline at which to start
        and stop performing slice analysis.
\item \verb|final_values_only| --- If nonzero, then slice quantities are computed
        only at the end of the beamline.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|subprocess|}\end{center}
\end{latexonly}
\subsection{subprocess \label{subsec:subprocess}}

\begin{itemize}
\item type: action command.
\item function: execute a system command in a shell.
\end{itemize}

\begin{verbatim}
&subprocess 
    STRING command = NULL;
&end
\end{verbatim}

\begin{itemize}
\item \verb|command| --- The text of the command to execute.  The command may
use the sequence ``%s'' for substitution of the rootname as set by \verb|run_setup|.
A literal ``%s'' must be entered as ``%%s''.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|steering_element|}\end{center}
\end{latexonly}
\subsection{steering\_element \label{subsec:steeringelement}}

\begin{itemize}
\item type: setup command.
\item function: setup for use of a given parameter of a given element as a steering corrector.
\item N.B.: any use of this command disables the built-in definition of HKICK, VKICK, and HVKICK elements
as steering elements.  For trajectory correction, this facility works without any effort by the user.
It will not work for orbit correction unless the user does two things: First, all correction elements
for each plane must be the same.  Second, the gain must be less than the ratio of the angle kick to
unit parameter change for the element.
\end{itemize}

\begin{verbatim}
&steering_element
    STRING name = NULL;
    STRING element_type = NULL;
    STRING item = NULL;
    STRING plane = "h";
    double tweek = 1e-3;
    double limit = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|name| --- Optional: the (possibly wild-carded) name of the element to add to the steering list.
        If not given, then \verb|element_type| must be given.
\item \verb|element_type| --- Optional: the (possibly wild-carded) name of the element type to add to the
        steering list.  If not given, then \verb|name| must be given.
\item \verb|item| --- The parameter of the element to be varied.
\item \verb|plane| --- May be either ``h'' or ``v'', for horizontal or vertical correction.
\item \verb|tweek| --- The amount by which to change the item to compute the steering strength.
\item \verb|limit| --- The maximum allowed absolute value of the item.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|touschek_scatter|}\end{center}
\end{latexonly}
\subsection{touschek\_scatter \label{subsec:touschekscatter}}
\begin{itemize}
\item type: setup/action command.
\item function: Simulate Touschek scattering process at each \verb|TSCATTER| element 
   based on Monte Carlo method. The local scattering rate is
   calculated by using Piwinski's formula and from the Monte Carlo
   simulation. Scattered particles can be tracked through the entire
   beamline (one pass only), and beam loss information is recorded.
\item notes: 
	\begin{itemize} 
      \item A momentum aperture file is required previous using this command. It
      should contain momentum aperture at least at each \verb|TSCATTER| element and can be
      obtained by running \verb|momentum_aperture| command. 
      \item The simulation can be done for a Gaussian distributed beam or an arbitrary 
      particle distribution given by histogram file(s) (See \verb|MHISTOGRAM|).  
      \item When using histogram file as input, it should contain data at least at each 
      \verb|TSCATTER| element. This can be done by inserting a \verb|MHISTOGRAM| element 
      following each \verb|TSCATTER| element. With \verb|lumped=1| option, a multi page 
      SDDS file will be output automatically or you can combine individual output file 
      into a multi page SDDS file before using this command.
      \item The input particle distribution can be given in 3 ways: 2D(x-x')+2D(y-y')+2D(dt-dp);
      or 4D(x-x'-y-y')+2D(dt-dp); or 6D(x-x'-y-y'-dt-dp); base on user's choice. We recommend
      to use lower ``order'' histogram table if the original particle number which used to generate
      these table is not large enough.
      \item The \verb|emit_*|, \verb|emit_dp| and \verb|sigma_s| is always required for running
      the simulation (Used for Piwinski's rate). Use closed value when simulate a non-Gaussian 
      distributed bunch. 
	\end{itemize}
\end{itemize}

\begin{verbatim}
&touschek_scatter
        double charge = 0;
        double frequency = 1;
        double emit_x = 0;
        double emit_nx = 0;
        double emit_y = 0;
        double emit_ny = 0;
        double sigma_dp = 0;
        double sigma_s = 0;
        double distribution_cutoff[3] = {3, 3, 3};
        double Momentum_Aperture_scale = 0.85;
        STRING Momentum_Aperture = NULL;
        STRING XDist = NULL;
        STRING YDist = NULL;
        STRING ZDist = NULL;
        STRING TranDist = NULL;
        STRING FullDist = NULL;
        STRING bunch = NULL;
        STRING loss = NULL;
        STRING distribution = NULL;
        STRING initial = NULL;
        STRING output = NULL;
        long nbins = 100;
        long n_simulated = 5E6;
        double ignored_portion = 0.01;
        long i_start = 0;
        long i_end = 1;
        long do_track = 0;
&end
\end{verbatim}

\begin{itemize}
   \item \verb|charge| --- Bunch charge in ``C''. Can not be zero.
   \item \verb|frequency| --- Bunch repeating frequency.
   \item \verb|emit_x|, \verb|emit_y| --- RMS emittance for the X, Y plane. Ignored 
   if RMS normalized emittance is nonzero.
   \item \verb|emit_nx|, \verb|emit_ny| --- RMS normalized emittance for the X, Y plane.
   \item \verb|sigma_dp|, \verb|sigma_s| --- Fractional momentum spread, $\delta$, and bunch length.
   \item \verb|distribution_cutoff| --- The number of sigmas to use at each plane for Gaussian beam.
   \item \verb|Momentum_Aperture| --- Input filename contains estimated momentum aperture at each
   \verb|TSCATTER| element.
   \item \verb|Momentum_Aperture_scale| --- This value times the aperture value from \verb|Momentum_Aperture|
   file sets up the limitation $\delta_m$ of the simulation. Only particles have $\delta>\delta_m$ 
   will be kept. And the scattering rate is calulated at this value.
   \item \verb|XDist|, \verb|YDist|, \verb|ZDist| --- Input filename of 2D histogram table of X, Y, and Z plane. 
   X and Y are ignored when \verb|TranDist| or \verb|FullDist| is present. 
   \item \verb|TranDist| --- Input file name of the 4D histogram table of transverse plane. 
   Has to be used together with \verb|ZDist|.
   \item \verb|FullDist| --- Input file name of the 6D histogram table. If present, all other 
   tables are ignored.
   \item \verb|bunch| --- The (incomplete) name of an SDDS file to which the phase-space coordinates of 
   the simulated scattered particles are to be written. Recommended value: ``\%s-\%03ld.bun''. If ``\%03ld''
   is not provided then only the last simulated bunch is kept (One bunch for one \verb|TSCATTER| element).
   \item \verb|loss| --- The (incomplete) name of an SDDS file to which the original and final 
   phase-space coordinates of the lost simulated scattered particles are to be written. 
   Recommended value: ``\%s-\%03ld.los''. Used together with \verb|do_track = 1|.
   \item \verb|distribution| --- The (incomplete) name of an SDDS file to which the one dimension 
   histogram of simulated scattered particles are to be written. Recommended value: ``\%s-\%03ld.dis'' 
   \item \verb|initial| --- The (incomplete) name of an SDDS file to which the one dimension 
   histogram of simulated particles before scattering are to be written. Recommended value: ``\%s-\%03ld.ini''
   \item \verb|output| --- The (incomplete) name of an SDDS file. The loss rate is summarized along the
   beamline and the average loss rate (particles per second per meter) at each location (1 m step) 
   is written to this file. Recommended value: ``\%s-\%03ld.out'' 
   \item \verb|nbins| --- Bin number used for the \verb|distribution| and \verb|initial| table.
   \item \verb|n_simulated| --- The total number of simulatted scattered particles with $\delta>\delta_m$. Small
   value will cause unstable simulation rate.
   \item \verb|ignored_portion| --- The total scattering rate ignored from tracking. This will greatly 
   increase the tracking speed. This number should be much less than the total loss rate. For example, if
   the total loss rate is 50\% of the total scattering rate, then ignor 5\% (0.05) of the scattering particles
   will cause some of 10\% error. But the simulation is greatly speed up.
   \item \verb|i_start|, \verb|i_end| --- The simulation will be done from the \verb|i_start| to \verb|i_end|
   \verb|TSCATTER| element along the beamline.    
   \item \verb|do_track| --- If non-zero, then scattered particles will be tracked from the location they are
   generated to the end of the beamline. The loss property can be analysised using \verb|output| or \verb|loss|. 
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|transmute_elements|}\end{center}
\end{latexonly}
\subsection{transmute\_elements \label{subsec:transmuteelements}}

\begin{itemize}
\item type: setup command.
\item function: Changes the type of selected elements, which may be used to
	turn off unneeded diagnostics and speed up tracking when concatenation
	is being used.
\item notes: 
	\begin{itemize}
	\item Any number of these commands may be given.
	\item Not effective unless given prior to \verb|run_setup|.
	\item The only property of the original element that is preserved is
	the length.  For example, transmuting a SBEN into a CSBEN will not
	have the expected result.
	\end{itemize}
\end{itemize}

\begin{verbatim}
&transmute_elements
	STRING name = NULL,
	STRING type = NULL,
	STRING exclude = NULL,
        STRING new_type = "DRIF",
        long disable = 0;
        long clear = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|name| --- Possibily wild-card containing string specifying the
	elements to which the transmutation specification is to be applied.
\item \verb|type| --- Possibily wild-card containing string specifying the
	element types to which the transmutation specification is to be applied.
\item \verb|exclude| --- Possibily wild-card containing string specifying 
	elements to be excluded from the specified transmutation.  Does not
	affect elements transmuted due to other specifications.
\item \verb|new_type| --- Type into which specified elements will be transmuted.
\item \verb|disable| --- If nonzero, the command is ignored.
\item \verb|clear| --- If nonzero, all prior transmutation specifications are deleted.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|twiss_analysis|}\end{center}
\end{latexonly}
\subsection{twiss\_analysis \label{subsec:twissanalysis}}

\begin{itemize}
\item type: setup command.
\item function: analyze Twiss parameters within a user-defined region for purposes of
        optimization.
\end{itemize}

\begin{verbatim}
&twiss_analysis
        STRING match_name = NULL;
        STRING start_name = NULL;
        STRING end_name = NULL;
        double s_start = -1;
        double s_end = -1;
        STRING tag = NULL;
        long verbosity = 0;
        long clear = 0;
&end
\end{verbatim}

\begin{itemize}
\item \verb|match_name| --- Optional wildcard string to match to element names for selection
  of elements to inculde in the analysis.
\item \verb|start_name| --- Name of the element at which to start analysis.  If the
        element occurs more than once, the first occurrence is used.
\item \verb|end_name| --- Name of the element at which to end analysis.  If the
        element occurs more than once, the first occurrence is used.
\item \verb|s_start| --- Position (in meters) at which to start analysis.
\item \verb|s_end| --- Position (in meters) at which to end analysis.
\item \verb|tag| --- Name prefix for quantities computed by the analysis.  The quantity
        names will have the form {\em tag}.{\em statistic}.{\em quantity}, where {\em statistic}
        is one of \verb|min|, \verb|max|, and \verb|ave|, and {\em quantity} is one of
        \verb|betax|, \verb|betay|, \verb|etax|, \verb|etay|, \verb|alphax|, \verb|alphay|, 
        \verb|etaxp|, and \verb|etayp|. E.g., if {\em tag} is \verb|region1|,
        then one could use expressions like \verb|region1.max.betax| in optimization.
\item \verb|clear| --- If nonzero, all previously defined analysis regions are deleted.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|twiss_output|}\end{center}
\end{latexonly}
\subsection{twiss\_output \label{subsec:twissoutput}}

\begin{itemize}
\item type: action/setup command.
\item function: compute and output uncoupled Twiss parameters, or set up to do so.
\end{itemize}

\begin{verbatim}
&twiss_output
    STRING filename = NULL;
    long matched = 1;
    long output_at_each_step = 0;
    long output_before_tune_correction = 0;
    long final_values_only = 0;
    long statistics = 0;
    long radiation_integrals = 0;
    long concat_order = 3;
    long higher_order_chromaticity = 0;
    long higher_order_chromaticity_points = 5;
    double higher_order_chromaticity_range = 4e-4;
    double chromatic_tune_spread_half_range = 0;
    long quick_higher_order_chromaticity = 0;
    double beta_x = 1;
    double alpha_x = 0;
    double eta_x = 0;
    double etap_x = 0;
    double beta_y = 1;
    double alpha_y = 0;
    double eta_y = 0;
    double etap_y = 0;
    STRING reference_file = NULL;
    STRING reference_element = NULL;
    long reference_element_occurrence = 0;
    long reflect_reference_values = 0;
    long cavities_are_drifts_if_matched = 1;
    long compute_driving_terms = 0;
    long local_dispersion = 1;
&end
\end{verbatim}

\begin{itemize}
\item \verb|filename| --- The (incomplete) name of an SDDS file to which the Twiss parameters will be written.
 Recommended value: ``\%s.twi''.
\item \verb|matched| --- A flag indicating, if set, that the periodic or matched Twiss parameters should be found.
\item \verb|output_at_each_step| --- A flag indicating, if set, that output is desired at each step of the simulation.
\item \verb|output_before_tune_correction| --- A flag indicating, if set, that output is desired both before and after
tune correction.
\item \verb|final_values_only| --- A flag indicating, if set, that only the final values of the Twiss parameters should
be output, and not the parameters as a function of s.
\item \verb|statistics| --- A flag indicating, if set, that minimum, maximum, and average values of
Twiss parameters should be computed and included in output.
\item \verb|radiation_integrals| --- A flag indicating, if set, that radiation integrals should be computed
and included in output. {\em N.B.: Radiation integral computation is not correct for systems with vertical
bending, nor does it take into account coupling.  See the \verb|moments_output| command if you need such
computations.}
\item \verb|beta_X|, \verb|alpha_X|, \verb|eta_X|, \verb|etap_X| --- If \verb|matched| is zero, the initial values for
the X plane.

\item \verb|concat_order| --- Order of matrix concatenation to use for
determining matrix for computation of Twiss parameters.  Using a lower
order will result in inaccuracy for nonlinear lattices with orbits
and/or momentum errors.  However, for on-momentum conditions with zero
orbit, it is much faster to use \verb|concat_order=1|.

\item \verb|higher_order_chromaticity| --- If nonzero, requests
computation of the second- and third-order chromaticity.  To obtain
reliable values, the user should use \verb|concat_order=3| in this
namelist and the highest available order for all beamline elements.
{\tt elegant} computes the higher-order chromaticity by finding the
trace of off-momentum matrices obtained by concantenation of the
matrix for \verb|higher_order_chromaticity_points| values of $\delta$
over the full range \verb|higher_order_chromaticity_range|.
If \verb|quick_higher_order_chromaticity| is nonzero, then a quicker concatenation method is
used that gives the second-order chromaticity only.

\item \verb|chromatic_tune_spread_half_range| --- Half range of $\delta$ for which the
        chromatic tune spread is computed.  The results are available in for optimization  and
        in the twiss output file under the names \verb|nuxChromUpper|, \verb|nuxChromLower|, 
        and similarly for the y plane.  This computation uses the chromaticities.

\item \verb|reference_file| --- If given, the name of a file from which twiss parameter data will
        be taken to give the starting values.  Ignored if \verb|matched| is nonzero.  The file
        should have the beta and alpha functions with the same names as the file created by
        this command.
\item \verb|reference_element| --- Element in \verb|reference_file| at which to take the
        twiss parameter values.  If not given, the values at the last element in \verb|reference_file|
        are used.
\item \verb|reference_element_occurrence| --- Ignored if \verb|reference_element| is not given.
        Otherwise, the occurence number of \verb|reference_element| to use.  If 0, the last
        occurence is used.
\item \verb|reflect_reference_values| --- If nonzero, reference values of $\alpha_{x,y}$ and $\eta^\prime_{x,y}$ are
  multiplied by -1.  This permits matching backwards from the reference point.
\item \verb|cavities_are_drifts_if_matched| --- By default,  if \verb|matched=1|, {\tt elegant} treats rf cavities
  as drift spaces, allowing the user to have a cavity in the ring definition without it affecting the lattice functions.
  By setting \verb|cavities_are_drifts_if_matched=0|, one can force {\tt elegant} to use the actual matrix for the
  rf cavity.  The differences between the 
  results are generally small, but the default behavior disagrees with the results of \verb|moments_output|.
  This feature is not available for cavities that change the beam energy (\verb|CHANGE_P0=1| in element definition 
  or \verb|always_change_p0=1| on \verb|run_setup|).
\item \verb|compute_driving_terms| --- If nonzero, then resonance driving terms \cite{Bengtsson} and
 tune shifts with amplitude are computed by summing over dipole, quadrupole, and sextupole elements.  For dipoles, only the effects of gradients and
 sextupole terms are included; curvature effects are not present in the theory.   In addition, these quantities may be optimized 
 by using those names in optimization terms (see list below).
\item \verb|local_dispersion| ---  Normally, {\tt elegant} will ignore acceleration in computing the
  dispersion.  That is, the dispersion would be the ``local'' dispersion $\frac{\partial x}{\partial \delta}$, where $\delta$
  was the local fractional momentum deviation.  In a linac or other systems with rf elements, one might also be interested in the ``global'' dispersion
  $\frac{\partial x}{\partial \delta_0}$, where $\delta_0$ is the energy deviation at the beginning of the system.
  In this case, set \verb|local_dispersion=0|.  Alternatively, one may look at the $R_{i6}$ elements of the matrix from 
  \verb|matrix_output|.
\end{itemize}

The output file from this command contains the following columns, giving values of quantities at the
exit of each element, unless otherwise noted.
\begin{itemize}
\item {\tt s} --- The arc length.
\item {\tt ElementName} --- The name of the element.
\item {\tt ElementType} --- The type name of the element.
\item {\tt betax} and {\tt betay} --- The horizontal and vertical beta functions.
\item {\tt alphax} and {\tt alphay} --- The horizontal and vertical alpha functions, where $\alpha = -\frac{d \beta}{2 ds}$.
\item {\tt psix} and {\tt psiy} --- The horizontal and vertical betatron phase advance in radians.
\item {\tt etax} and {\tt etay} --- The horizontal and vertical dispersion functions.
\item {\tt etaxp} and {\tt etayp} --- The slopes of the horizontal and vertical dispersion functions.
\item {\tt xAperture} and {\tt yAperture} --- The horizontal and vertical apertures.  If undefined, will have a 
 value of 10m.  If the beam trajectory is non-zero, then the aperture will be changed (usually reduced) accordingly.  Hence, these
 are best understood as the {\tt effective} apertures.  They are used in determining the horizontal and vertical acceptance
 parameters, {\tt Ax} and {\tt Ay}.
\item {\tt pCentral0} --- The central momentum ($\beta\gamma$) at the {\bf entrance} to the element.
\item {\tt dI}{\em n} --- Contribution to radiation integral {\tt I}{\em n}.  Radiation integrals take account of
  horizontal bending only.
\end{itemize}

The output file contains the following parameters.  Note that chromatic quantities depend on the order 
settings of the individual elements, the default order (in \verb|run_setup|), and the concatenation order
given in the \verb|twiss_output| command.  These quantities pertain to the end of the lattice or to the
lattice as a whole.
\begin{itemize}
\item {\tt nux} and {\tt nuy} --- The horizontal and vertical tunes.
\item {\tt dnux/dp} and {\tt dnuy/dp} --- The horizontal and vertical chromaticities, defined as $d\nu/d\delta$.
\item {\tt dnux/dp2} and {\tt dnuy/dp2} --- The horizontal and vertical 2nd-order chromaticities, 
  defined as $d^2\nu/d\delta^2$.  Will be zero if \verb|higher_order_chromaticity| is zero.
\item {\tt dnux/dp3} and {\tt dnuy/dp3} --- The horizontal and vertical 3rd-order chromaticities, 
  defined as $d^3\nu/d\delta^3$.  Will be zero if \verb|higher_order_chromaticity| is zero.
\item {\tt dbetax/dp} and {\tt dbetay/dp} --- Chromatic derivatives of the horizontal and vertical beta functions,
defined as $\frac{d\beta}{d\delta}$.
\item {\tt etax2}, {\tt etax3}, {\tt etay2}, {\tt etay3} --- Higher order dispersion in the horizontal and
  vertical planes.  For example, for the horizontal plane, the closed orbit at the end of the lattice 
  depends on $\delta$ according to
  $x = \eta_x\delta + \eta_{x2} \delta^2 + \eta_{x3}\delta^3$.  This differs from the chromaticity expansion,
  which is given in terms of successive derivatives of $\nu(\delta)$.
\item {\tt dnux/dAx}, {\tt dnux/dAy}, {\tt dnuy/dAx}, {\tt dnuy/dAy} --- Tune shifts with amplitude, where amplitude
  is defined as $A_q = (1 + \alpha_q) q^2/\beta_q$, with $q=x$ or $q=y$.  These will
  be zero unless the \verb|tune_shift_with_amplitude| command is given.
\item {\tt h11001}, {\tt h00111}, {\tt h20001}, {\tt h00201}, {\tt h10002}, {\tt h21000}, {\tt h30000}, {\tt h10110}, {\tt h10020},
{\tt h10200}, {\tt h22000}, {\tt h11110}, {\tt h00220}, {\tt h31000}, {\tt h40000}, {\tt h20110}, {\tt h11200}, {\tt h20020},
{\tt h20200}, {\tt h00310}, {\tt h00400}--- Resonance driving terms\cite{Bengtsson}.  These will be
 zero unless \verb|compute_driving_terms| is nonzero.  See table \ref{tab:drivingTerms} for an explanation of each term.
\item {\tt dnux/dJx}, {\tt dnux/dJy},  and {\tt dnuy/dJy} --- Tune shifts with amplitude from Bengtsson's theory \cite{Bengtsson}.
 See documentation for \verb|tune_shift_with_amplitude| for discussion and comparison with {\tt dnux/dAx} etc.
 These will be zero unless \verb|compute_driving_terms| is nonzero.
\item {\tt Ax} and {\tt Ay} --- The horizontal and vertical acceptance.  These will be zero if no apertures are
  defined.
\item {\tt alphac}, {\tt alphac2} --- First- and second-order momentum compaction.  The path length is 
  $s = s_o + \alpha_c L \delta + \alpha_{c2} L \delta^2$.
\item {\tt couplingIntegral}, {\tt couplingDelta}, and {\tt emittanceRatio} --- These quantities are defined
  in section 3.1.4.4 of \cite{HAPE}.  The computations include tilted quadrupoles, vertical orbit in sextupoles,
  vertical sextupole displacement, and solenoids.  Note that the emittance ratio {\em does not} include 
  the effect of vertical dispersion.
\item {\tt I}{\em n} --- The $n^{\rm th}$ radiation integral.
\item {\tt taux}, {\tt tauy}, {\tt taudelta} --- Radiation damping times for x, y, and $\delta$.
\item {\tt Jx}, {\tt Jy}, {\tt Jdelta} --- Damping partition factors for  x, y, and $\delta$.
\item {\tt ex0}, {\tt enx0} --- Horizontal equilibrium geometric and normalized emittances.
\item {\tt Sdelta0} --- Equilibrium fractional rms energy spread.
\item {\tt U0} --- Energy loss per turn.
\end{itemize}

N.B.: the higher-order dispersion and higher-order chromaticity are
computed using the concatenated third-order matrix.  However, {\tt
elegant} only has third-order matrices for three elements:
alpha magnets, quadrupoles, and sextupoles.  This may be acceptable if
any dipoles (for example) have large bending radius.  Users who are
concerned about these effects should perform off-energy tracking using
canonical elements (i.e., CSBEND, KQUAD, KSEXT, and MULT), which
include energy dependence to all orders.

Also, note that by default all elements are computed to second order
only.  You must change the \verb|default\_order| parameter on
\verb|run\_setup| to \verb|3| in order to use the third-order matrices
for alpha magnets, quadrupoles, and sextupoles.  You may also use the
{\tt ORDER} parameter on individual element definitions.

\begin{table}[htb]\caption{Meaning of the various driving terms\cite{Bengtsson}.}
\begin{center}
\begin{tabular}{|c|c|}\hline
Term Name & Explanation \\  \hline \hline
h11001 & drives x chromaticity \\ \hline
h00111 & drives y chromaticity \\ \hline
h20001 & drives synchro-betatron resonances \\ \hline
h00201 & drives momentum-dependence of beta functions \\ \hline
h10002 & drives second order dispersion \\ \hline
h21000 & drives $\nu_x$ \\ \hline
h30000 & drives $3 \nu_x$ \\ \hline
h10110 & drives $\nu_x$ \\ \hline
h10020 & drives $\nu_x - 2 \nu_y$ \\ \hline
h10200 & drives $\nu_x + 2 \nu_y$ \\ \hline
h22000 & drives $d\nu_x/dJ_x$\\ \hline
h11110 & drives $d\nu_x/dJ_y$ \\ \hline
h00220 & drives $d\nu_y/dJ_y$ \\ \hline
h31000 & drives $2 \nu_x$ \\ \hline
h40000 & drives $4 \nu_x$ \\ \hline
h20110 & drives $2 \nu_x$ \\ \hline
h11200 & drives $2 \nu_y$ \\ \hline
h20020 & drives $2 \nu_x - 2 \nu_y$ \\ \hline
h20200 & drives $2 \nu_x + 2 \nu_y$ \\ \hline
h00310 & drives $2 \nu_y$ \\ \hline
h00400 & drives $4 \nu_y$ \\ \hline
\end{tabular}
\end{center}
\label{tab:drivingTerms}
\end{table}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|track|}\end{center}
\end{latexonly}
\subsection{track \label{subsec:track}}

\begin{itemize}
\item type: major action command.
\item function: track particles.
\end{itemize}

\begin{verbatim}
&track
    long center_on_orbit = 0;
    long center_momentum_also = 1;
    long offset_by_orbit = 0;
    long offset_momentum_also = 1;
    long soft_failure = 1;
    long use_linear_chromatic_matrix = 0;
    long longitudinal_ring_only = 0;
    long stop_tracking_particle_limit = -1;
&end
\end{verbatim}

\begin{itemize}
\item \verb|center_on_orbit| --- A flag indicating whether to center
the beam transverse coordinates on the closed orbit before tracking.
\item \verb|center_momentum_also| --- A flag indicating whether to
center the momentum coordinate also.
\item \verb|offset_by_orbit| --- A flag indicating whether to offset
the transverse beam coordinates by the closed orbit before tracking.
Similar to \verb|center_on_orbit|, but the initial centroids of the
beam are preserved.  The beam is simply displaced by the closed orbit
rather than being centered on it.
\item \verb|offset_momentum_also| --- A flag indicating whether to also
offset the beam momentum to the momentum of the closed orbit.  If the
\verb|start_from_centroid| or \verb|start_from_dp_centroid| parameters are 
used on the \verb|closed_orbit| command, this flag should be set to
0; otherwise, one will offset the beam central momentum by its own value.
\item \verb|soft_failure| --- If there is an error during tracking (e.g.,
a failure of orbit correction), continue to produce file output.  This
creates essentially empty slots in the files corresponding to the failed
steps.
\item \verb|use_linear_chromatic_matrix| --- For each particle, a first-order
matrix is computed for the particular momentum offset 
of the particle using the linear chromaticity and linear dependence of 
the beta functions on momentum.
\item \verb|longitudinal_ring_only| --- Tracks longitudinal coordinates only
for a ring.  
\item \verb|stop_tracking_particle_limit| --- If a non-negative is given, then
{\tt elegant} will stop tracking when the number of particles falls below the
given value.  It will be as if all the particles were lost.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|tune_shift_with_amplitude|}\end{center}
\end{latexonly}
\subsection{tune\_shift\_with\_amplitude \label{subsec:tuneshiftwithamplitude}}

\begin{itemize}
\item type: setup command.
\item function: prepare for computation of tune shifts with amplitude.
\item note: must be given prior to the \verb|twiss_output| command.
\item methods: 
\begin{itemize}
 \item[Method 1]: tune shifts with amplitude are computed via tracking a series of
  particles at different amplitudes or by a matrix method.  NAFF is used to 
  determine the tunes from the tracking data.  It is the user's responsbility to optimize the
  parameters to ensure that results are reasonable.  
 \item[Method 2]: tune shifts are computed using a concatenated multi-turn third-order matrix.
 This appears to be reliable for many cases we've tested.
 \item[Method 3]: tune shifts can be computed quickly using Bengtsson's formulae \cite{Bengtsson} by
 setting \verb|compute_driving_terms=1| in \verb|twiss_output|.  For cases where all methods are
 valid, the results will differ by a factor of 2 from the results obtained with this command.
 Also, the present command has more general validity because it includes dipole curvature effects.
\end{itemize}

The quantities computed are $\frac{\partial}{\partial A_x^n \partial A_y^m}\nu_p$, where $n\geq 0$ and $m \geq 0$ are
integers and $p$ is $x$ or $y$.  $A_q = (1 + \alpha_q) q^2/\beta_q$, with $q=x$ or $q=y$.

\end{itemize}

\begin{verbatim}
&tune_shift_with_amplitude
    long turns = 2048;
    double x0 = 1e-6;
    double y0 = 1e-6;
    double x1 = 3e-4;
    double y1 = 3e-4;
    long grid_size = 6;
    long lines_only = 0;
    long sparse_grid = 0;
    long spread_only = 0;
    double nux_roi_width = 0.02;
    double nuy_roi_width = 0.02;
    double scale_down_factor = 2;
    double scale_up_factor = 1.05;
    double scale_down_limit = 0.01;
    double scale_up_limit = 1e-4;
    long scaling_iterations = 10;
    long use_concatenation = 0;
    long verbose = 0;
    long order = 2;
    STRING tune_output = NULL;
&end
\end{verbatim}

\begin{itemize}
\item \verb|turns| --- The number of turns to track.  If zero, then the concatenated matrix
        is used instead of tracking, and all other parameters of this command are irrelevant.  
        The matrix method doesn't work well with all lattices.  The order
        of the concatenated matrix is given by the \verb|concat_order| control in 
        \verb|twiss_output|.
\item \verb|x0|, \verb|y0| --- The initial x and y amplitudes to use for determining the
        small-amplitude tunes.
\item \verb|x1|, \verb|y1| --- The initial x and y amplitudes to user for determining the
        tune shifts.  These values should be small enough to ensure linearity in the tune
        shift.  
\item \verb|grid_size| --- Size of the grid of points in x and y.  
\item \verb|lines_only| --- If nonzero, then instead of a full set of \verb|grid_size|$^2$
  particles, only two lines of particles with $x=0$ and/or $y=0$ are tracked.  In this
  case, no $A_x^i*A_y^j$ terms are computed (except for $i=0$ or $j=0$).  However, in addition
  to being faster, the results may be more reliable, e.g., $\partial \nu_x/\partial A_y = 
  \partial \nu_y/\partial A_x$ may be more closely satisfied.
\item \verb|sparse_grid| --- If nonzero, then instead of a full set of \verb|grid_size|$^2$
        particles, a sparse grid of particles is tracked.  Will save time at some expense
        in accuracy.
\item \verb|spread_only| --- Compute the tune spread only and don't bother with the
        tune shift coefficients.  These tune spreads can be optimized and appear in the
        twiss output file under the names \verb|nuxTswaLower|, \verb|nuxTswaUpper|, and
        similarly for the y plane.  This is the recommended way to reduce tune shift
        with amplitude, as the tune spread is more reliable than the coefficients of 
        the expansion.  (Particles that get lost are automatically ignored in both
        types of computations.)
\item \verb|nux_roi_width|, \verb|nuy_roi_width| --- Widths of the region of interest for
        x and y tunes.  As the grid is filled in, {\tt elegant} finds the tune for each
        tracked particle on the grid.  Successive tune values are looked for in the
        region of the given width around the previous tune value.  This prevents jumping
        from the main tune peak to another peak, which can happen when the tune spectrum
        has many lines.
\item \verb|scale_down_factor|, \verb|scale_up_factor|, \verb|scale_down_limit|, 
        \verb|scale_up_limit|, \verb|scaling_iterations| --- These control automatic scaling
        of the amplitudes.  If {\tt elegant} sees a tune shift larger than \verb|scale_down_limit|
        it will decrease \verb|x0| (or \verb|y0|) by the factor \verb|scale_down_factor|. 
        If  {\tt elegant} sees a tune shift smaller than \verb|scale_up_limit|
        it will increase \verb|x0| (or \verb|y0|) by the factor \verb|scale_up_factor|. 
        Suggestion: if you find yourself playing with these values and the initial amplitudes
        in order to get reliable TSWA coefficients, try just using the tune spread.
\item \verb|verbose| --- If nonzero, information about the progress of the algorithm is 
        printed to the screen.
\item \verb|use_concatenation| --- If nonzero, then tracks with the concatenated matrix instead
        of element-by-element.  The order
        of the concatenated matrix is given by the \verb|concat_order| control in
        \verb|twiss_output|. The user should experiment with this option to see if the
        results are reliable for a particular lattice.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|vary_element|}\end{center}
\end{latexonly}
\subsection{vary\_element \label{subsec:varyelement}}

\begin{itemize}
\item type: setup command.
\item function: define an index and/or tie a parameter of an element to it.
\item N.B.: It is not possible to vary an element if the element name starts with one of the following
characters: 
\verb|0|, \verb|1|, \verb|2|, \verb|3|, \verb|4|, \verb|5|, \verb|6|, \verb|7|, \verb|8|,
\verb|9|, \verb|.|, \verb|+|, or \verb|-|.  The reason is that {\tt elegant} will attempt to 
make an SDDS parameter name containing the element name, and these characters are disallowed
at the beginning of such a name.
\end{itemize}

\begin{verbatim}
&vary_element
    long index_number = 0;
    long index_limit = 0;
    STRING name = NULL;
    STRING item = NULL;
    double initial = 0;
    double final = 0;
    long differential = 0;
    long multiplicative = 0;
    long geometric = 0;
    STRING enumeration_file = NULL;
    STRING enumeration_column = NULL;
&end
\end{verbatim}

\begin{itemize}
\item \verb|index_number| --- A non-negative integer giving the number of the index.
\item \verb|index_limit| --- A positive integer giving the number of values the index will take.
 Must be given if this \verb|index_number| has not been listed in a previous \verb|vary_element|
command, unless \verb|enumeration_file| is given.
\item \verb|name| --- The name of an element.
\item \verb|item| --- The parameter of the element to vary.
\item \verb|initial|, \verb|final| --- The initial and final values of the parameter.
\item \verb|enumeration_file| --- Name of an SDDS file giving values for the item.
\item \verb|enumeration_column| --- Column of the SDDS file giving the values.
\item \verb|differential| --- If nonzero, the initial and final values are taken as
offsets from the predefined value of the parameter.
\item \verb|multiplicative| --- If nonzero, the initial and final values are taken as 
multipliers to be applied to the predefined value of the parameter in order to obtain
the actual initial and final values.
\item \verb|geometric| --- If nonzero, then variation is geometric rather than 
arithmetic.
\end{itemize}

\newpage
\section{Specialized Tools for Use with {\tt elegant}}

A number of specialized programs are available that work with {\tt
elegant}. Most are SDDS-compliant, so they will also work with any
program that reads or writes appropriate SDDS data.  The following is
a brief description of each program.  Full descriptions for most programs are available
on subsequent pages.  Most programs will return a help message if the program name is
given with no arguments.
\begin{itemize}
\item {\tt astra2elegant} --- Converts ASCII particle output from ASTRA \cite{ASTRA} to a binary
  SDDS file suitable for use with {\tt elegant}.  This program is recommended over
  the astra2sdds program on the ASTRA website, because the latter produces ASCII SDDS
  files that are quite slow to read and does not perform the correct computations
  for low-energy beams.
\item {\tt csrImpedance} --- Computes the shielded steady-state CSR impedance for a dipole magnet.
 The output can be used immediately with {\tt elegant}'s \verb|ZLONGIT| element.
 (Program by Y. Wang, H. Shang, and M. Borland.)
\item {\tt doubleDist6} --- Increases the number of particles in a particle input file by
 successively doubling the number.  Intended to be used to increase the number of particles
 produced by a photoinjector simulation to improve stability of CSR and LSC simulations.
 See also {\tt smoothDist6}.
\item {\tt elegant2astra} --- This program translates {\tt elegant} phase space files into ASTRA \cite{ASTRA} format.
\item {\tt elegant2track} --- This program translates {\tt elegant} phase space files into TRACK \cite{TRACK} format.
  The ASCII version of TRACK is assumed.
\item {\tt elegant2genesis} --- This program performs
        slice analysis of particle output files, which are suitable for use with
        the SDDS-compliant APS version of GENESIS\cite{GENESIS}.  This program is
        part of the SDDS toolkit.  See the SDDS toolkit
        manual for documentation. (Program by R. Soliday and M. Borland.)
\item {\tt haissinski} --- Computes the steady-state longitudinal distribution in
        an electron storage ring.  Requires as input a file containing the Twiss
        parameters around the ring, such as that provided by the \verb|twiss_output| command.
        (Program by L. Emery and M. Borland.)
\item {\tt ibsEmittance} --- Computes local intra-beam scattering rates for both storage ring
        and linac. Also computes the equlibrium transverse and longitudinal emittances of a 
        beam in an electron storage ring, resulting from the combination of quantum excitation,
        damping, and intra-beam scattering.  Requires as input a file containing the
        Twiss parameters, such as that provided by the \verb|twiss_output| command.
        (Program by L. Emery, M. Borland, and A. Xiao)
\item {\tt impact2elegant} --- Tranlates IMPACT-T \cite{IMPACT} output into {\tt elegant} conventions.
\item {\tt impact2sdds} --- Translates IMPACT-T output files into SDDS for easier postprocessing.
\item {\tt madto} --- Translates an {\tt elegant}-style lattice file (or a MAD file, with
        some restrictions) into formats accepted by other programs, such as COSY, PARMELA, 
        PATPET, PATRICIA, TRANSPORT, and XORBIT.  Will also generate an SDDS file containing lattice
        data.  (Program by M. Borland.)
\item {\tt sddsanalyzebeam} --- Analyzes a beam of macro-particles and produces an SDDS file
        containing beam moments, emittances, equivalent beta functions, etc.  The beam file
        is of the type written by {\tt elegant} using the {\tt output} field of the {\tt run\_setup}
        command, or the WATCH element.  (Program by M. Borland.)
\item {\tt sddsbrightness} --- Uses twiss parameter output or data from {\tt sddsanalyzebeam} to
  compute undulator brightness curves.  (Program by H. Shang, R. Dejus, M. Borland, X. Jiao.)
\item {\tt sddsemitproc} --- Analyzes quadrupole scan emittance measurement data.  Accepts a
        file containing the transport matrix for each point and measured beam sizes.  
        The file may, for example, be the file produced
        by the {\tt final} field of the {\tt run\_setup} command.  The quadrupole scan can be
        executed inside of {\tt elegant} using {\tt vary\_elements}. (Program by M. Borland.)
\item {\tt sddsfluxcurve} --- Uses twiss parameter output or data from {\tt sddsanalyzebeam} to
  compute undulator flux tuning curves.  (Program by M. Borland, H. Shang, R. Dejus.)
\item {\tt sddsmatchtwiss} --- Transforms a beam of macro-particles to match to given beta
        functions and dispersion.    The beam file
        is of the type written by {\tt elegant} using the {\tt output} field of the {\tt run\_setup}
        command, or the WATCH element. (Program by M. Borland.)
\item {\tt sddsurgent} --- Uses algorithms from the programs US (by R. Dejus) and URGENT (by R. Walker) for computation of undulator
  radiation properties, including power density and intensity distributions.  (Program by H. Shang, R. Dejus, M. Borland, X. Jiao.)
\item {\tt sddsrandmult} --- Simulates the effect of random mechanical errors in a quadrupole or sextupole,
  generating multipole error data that can be used with {\tt elegant}'s {\tt KQUAD} and {\tt KSEXT}
  elements. (Program by M. Borland.)
\item {\tt sddssampledist} --- This program allows creating particle
        distributions from user-designed distribution functions.  It is thus a more flexible alternative
        to \verb|bunched_beam|.  This program is part of the SDDS toolkit.  See the SDDS toolkit
        manual for documentation.  (Program by M. Borland and H. Shang.)
\item {\tt smoothDist6s} --- Increases the number of particles in an input particle distribution.  At the same
 time, smooths the distribution and adds optional energy and density modulation.   Intended to be used to increase the number of particles
 produced by a photoinjector simulation to improve stability of CSR and LSC simulations.  Also useful in studying 
 the growth rate for energy and density modulations.  See also {\tt doubleDist6}.
\item The script \verb|spiffe2elegant| allows converting the output of the PIC code \verb|spiffe| to the same form
  as output by \verb|elegant|.  Note that \verb|elegant| will read \verb|spiffe| output directly. This script just allows converting the
  data for use with related programs, such as \verb|sddsanalyzebeam|.
\item {\tt touschekLifetime} --- This program calculates Touschek lifetime using A. Piwinski's formula.
        Input files are generated from ``twiss\_output'' and ``momentum\_aperture''.  (Program by A. Xiao.)
\item {\tt track2sdds} --- Translates output files, including phase space files, from version 39 of TRACK (with ASCII output \cite{TRACK})
  into SDDS. 
\item {\tt track2mag} --- Uses TRACK output files to create a file similar to the magnets outupt file from {\tt elegant}.
  This gives a profile of the beamline that can be plotted with other data.
\item The scripts \verb|makeSkewResponseCP| and \verb|correctCoupling| can be used to compute the cross-plane response
  matrices for skew quadrupoles and to perform coupling correction using those matrices.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|astra2elegant|}\end{center}
\end{latexonly}
\subsection{astra2elegant}

\begin{itemize}
\item {\bf description:}   Converts ASCII particle output from ASTRA to a binary
SDDS file suitable for use with {\tt elegant}.  This program is recommended over
the astra2sdds program on the ASTRA website, because the latter produces ASCII SDDS
files that are quite slow to read.

\item {\bf synopsis:}
\begin{flushleft}{\tt
astra2elegant [{\em inputFile}] [{\em outputFile}] [-centerReference] [-pipe=[input][,output]]
}\end{flushleft}

\item {\bf files:}
\begin{itemize}
\item {\tt inputFile} --- ASCII particle output file from ASTRA.
\item {\tt outputFile} --- SDDS file containing phase space data. May be used directly with 
{\tt elegant}.
\end{itemize}

\item {\bf switches:}
\begin{itemize}
\item {\tt -centerReference} --- Normally, {\tt astra2elegant} offsets the arrival time of all particles
  by the arrival time of the reference particle.  This behavior can be suppressed by giving the
  {\tt -centerReference} option.  In that case, the arrival time of the reference particle is defined
  as 0.
\item {\tt -pipe[=input][,output]} --- Standard SDDS toolkit pipe option.
\end{itemize}

\item {\bf authors:} M. Borland (ANL/APS).

\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|csrImpedance|}\end{center}
\end{latexonly}
\subsection{csrImpedance}

\begin{itemize}
\item {\bf description:}  Computes the steady-state CSR impedance with shielding by parallel plates.
By default, the computed impedance is for a dipole magnet that bends the beam in a complete circle.

\item {\bf synopsis:}
\begin{flushleft}{\tt
csrImpedance {{\em outputFile}  | -pipe[=out]} -height={\em valueInMeters} -radius={\em valueInMeters}
-frequencyLimit=maximum={\em valueInHz}[,minimum={\em valueInHz}] -n={\em integer} [-filter={\em cutoff1},{\em cutoff2}]
[-angle={\em radians}]
}\end{flushleft}

\item {\bf files:}
\begin{itemize}
\item {\tt outputFile} --- SDDS file containing computed impedance.  May be used directly with 
{\tt elegant}'s \verb|ZLONGIT| element.
 as columns, along with analysis and conditions as parameters.
\end{itemize}

\item {\bf switches:}
\begin{itemize}
\item {\tt -height} --- The full height of the vacuum chamber, in meters.
\item {\tt -radius} --- The radius of the bending magnet, in meters.
\item {\tt -angle} --- The angle of the bending magnet, in radians.  The default is $2\pi$.
\item {\tt frequencyLimit} --- Allows specifying the upper frequency limit (required), as well as the
 lower frequency limit, for the computed impedance.  {\tt elegant} will not accept the data if the lower
 limit is not 0.  If the rms bunch length is $\sigma_t$, then it is suggested to have the maximum frequency 
 much greater than $1/(2\pi\sigma_t)$.
\item {\tt -n} --- Allows specifying the number of data points to be computed. The number of points computed
 is $2^n+1$, which is required by {\tt elegant}.  A reasonable value is $n=10$ to $n=14$.
\item {\tt -filter} --- Allows specifying the starting and ending frequency for a simple low-pass filter.
 The frequencies are given as fractions of the maximum frequency.  The filter ramps linearly from 1 to 0
 between the two cutoff values.  If, for example, the cutoff is 0.2, then the highest frequency
 in the impedance corresponds to a wavelength of 10 bins ($2/0.2$) in {\tt elegant}.
\end{itemize}

\item {\bf authors:} Y. Wang, H. Shang, ANL/APS.
Based on a simplified form\cite{Agoh} of Warnock's \cite{Warnock} formula.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|doubleDist6|}\end{center}
\end{latexonly}
\subsection{doubleDist6}

\begin{itemize}
\item {\bf description:} Increases the number of particles in a particle input file by
 successively doubling the number.  Intended to be used to increase the number of particles
 produced by a photoinjector simulation to improve stability of CSR and LSC simulations.

The algorithm is as follows:
\begin{itemize}
\item For each doubling, insert a new particle ``near'' every pair of existing particles in time.
    The particle has a new t value, but the same (x, xp, y, yp, p) as one of the original particles.
\item Bin the beam according to t into a large number of bins.  Randomize the assignment of p values
    relative to other coordinates across particles in the same bin, while additionally adding a 
    small random value to each p value.
\end{itemize}

\item {\bf synopsis:}
\begin{flushleft}{\tt
doubleDist6 -input {\em name} -output {\em name} -doublings {\em number} -nt {\em bins}
}\end{flushleft}

\item {\bf files:}
\begin{itemize}
\item {\tt input} --- A particle distribution file, such as might be used with \verb|sdds_beam|.
\item {\tt output} --- A particle distribution file, such as might be used with \verb|sdds_beam|.
\end{itemize}

\item {\bf switches:}
\begin{itemize}
\item {\tt -doublings {\em n}} --- The number of times to double the size of the distribution.
 The number of particles in the output file is $2^n$ times the number in the input file.
\item {\tt -nt {\em bins}} --- The number of time bins to use for momentum randomization. This
 helps to avoid having many particles with exactly same momentum.
\end{itemize}

\item {\bf author:} M. Borland, ANL/APS.

\item {\bf see also:} {\tt smoothDist6s}
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|haissinski|}\end{center}
\end{latexonly}
\subsection{haissinski}

\begin{itemize}
\item {\bf description:}  {\tt haissinski} solves the Haissinski equation for the bunch
 steady-state longitudinal distribution in the presence of various impedances.

\item {\bf synopsis:}
\begin{flushleft}{\tt
haissinski {\em twissFile} {\em resultsFile}
 {-wakeFunction={\em file},tColumn={\em name},wColumn={\em name} |
  -model=[L={\em Henry}|Zn={\em Ohms}],R={\em Ohm}} 
 {-charge={\em C} | -particles={\em value} | -bunchCurrent={\em A}}
 {-steps={\em numberOfChargeSteps}}
 {-outputLastStepOnly}
 {-RF=Voltage={\em V},harmonic={\em value} | -length={\em s}}
 {-harmonicCavity=Voltage={\em V},factor={\em harmonicFactor}}
 {-superPeriods={\em number}}
 {-energy={\em GeV}} 
 -integrationParameters=deltaTime={\em s},points={\em number},startTime={\em s},
iterations={\em number},fraction={\em value},tolerance={\em value} 
}\end{flushleft}

\item {\bf files:}
\begin{itemize}
\item {\em twissFile} --- Twiss output file from {\tt elegant}, including radiation
 integral calculations.
\item {\tt resultsFile} --- SDDS file containing computed bunch longitudinal distributions
 as columns, along with analysis and conditions as parameters.
\end{itemize}

\item {\bf switches:}
\begin{itemize}
\item {\tt -wakeFunction={\em file},tColumn={\em name},wColumn={\em name}} --- Optionally
 specifies the impedance as a Greens function using values in an SDDS file.  The time points
 must be equi-spaced.
\item {\tt -model=[L={\em Henry}|Zn={\em Ohms}],R={\em Ohm}} --- Optionally specifies the
 impedance as an inductor {\tt L} or broad-band value {\tt  Zn}, along with  a resistance {\tt R}.
\item {\tt -charge={\em C} | -particles={\em value} | -bunchCurrent={\em A}} --- Various 
 ways to specify the charge in each bunch.
\item {\tt -steps={\em numberOfChargeSteps}} --- Number of values of bunch charge to compute 
 up to the value specified with on the just-described options.  Using more values can help
 convergence, as the result of each prior step is used as the starting point for the new step.
\item {\tt -outputLastStepOnly}  --- Requests output for the last charge step (full charge) only.
\item {\tt -RF=Voltage={\em V},harmonic={\em value} | -length={\em s}} --- Two ways to specify 
 the nominal bunch length.
\item {\tt -harmonicCavity=Voltage={\em V},factor={\em harmonicFactor}} --- Specifies a harmonic
 cavity voltage and the ratio of the harmonic cavity frequency to the main frequency.
\item {\tt -superPeriods={\em number}} --- Number of superiods of the lattice specified in
 {\em twissfile} to simulate.  If one has an N cell ring but only gives 1 cell in the input,
 this value should be N.  If one gives the whole ring, this value should be 1.
\item {\tt -energy={\em GeV}} --- Beam energy. If not given, the value in the {\em twissfile} 
 is used.
\item {\tt -integrationParameters=deltaTime={\em s},points={\em number},startTime={\em s},}\\
 {\tt iterations={\em number},fraction={\em value},tolerance={\em value} } --- Integration 
 parameters, which must be set.  {\tt deltaTime} is the time interval for wake function and
 charge density evaluation.  {\tt points} is the number of time points, while {\tt startTime}
 is the time (relative to synchronous phase) at which the time region starts.  These values
 must be set by the user based on knowledge of the likely bunch length.  For the others, 
 we suggest 1000 iterations, a fraction of 0.01, and a tolerance of $10^{-4}$. 
\end{itemize}

\item {\bf authors:} L. Emery, M. Borland, ANL/APS.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|ibsEmittance|}\end{center}
\end{latexonly}
\subsection{ibsEmittance}

\begin{itemize}
\item {\bf description:} \verb|ibsEmittance| computes growth rates and
equilibrium emittances for electron rings due to intrabeam scattering
(IBS).  It will also integrate the growth rates to show the time
evolution of the emittances.  The IBS algorithm is based on the
Bjorken and Mtingwa's~\cite{BM} formula, and with an extension of including vertical
dispersion. The program can also estimate IBS growth rates
for and transport line or linac beam, provided special attention paid to the beam's energy
change (splitting RF cavities as needed). 

\item {\bf examples:}
This example computes the IBS equilibrium parameters and the contributions to the
growth rates (at equilibrium) vs position in the APS lattice.
\begin{flushleft}{\tt 
ibsEmittance aps.twi aps.ibs -charge=5 -coupling=0.02 -rf=voltage=9,harmonic=1296
}\end{flushleft}

\item {\bf synopsis:}
\begin{flushleft}{\tt 
ibsEmittance {\em twissFile} {\em resultsFile}
 {-charge=<nC>|-particles=<value>} -coupling=<value>
 [-emitxInput=<value>] [-deltaInput=<value>] 
 [-superperiods=<value>] [-isRing=1|0]
 \{-RF=Voltage=<MV>,harmonic=<value>|-length=<mm>\}
 [-energy=<MeV>] 
 [\{-growthRatesOnly | -integrate=turns=<number>[,stepSize=<number>]\}]
 [-noWarning] 
}\end{flushleft}

\item {\bf files:}
{\em twissFile} is a twiss parameter file from the \verb|twiss_output| command of
{\tt elegant}.    You must use the \verb|radiation_integrals| flag in \verb|twiss_output|.

\item {\bf switches:}
\begin{itemize}
\item {\bf -charge}, {\bf -particles} --- Give the charge (in nanocoulombs) or the
 number of electrons.
\item {\bf -coupling} --- Give the emittance coupling ratio, $\epsilon_y/\epsilon_x$.
\item {\bf -emitxInput} --- Give the initial x emittance in meters.  If not specified,
the value from the parameter \verb|ex0| in {\em twissFile} is used.
\item {\bf -deltaInput} --- Give the initial rms fractional momentum spread.  If not
specified, the value from the parameter \verb|Sdelta0| in {\em twissFile} is used.
\item {\bf -superperiods={\em value}} --- If given, the number of superperiods in the 
lattice.  {\em twissFile} is taken to pertain to a single sector.
\item {\bf -isRing} --- Specify the calculation is done for stored beam 
(isRing=1, default) or transport line/linac beam (isRing=0). When isRing is set to 0, the energy scaling
and integration calculation will be disabled.  
\item {\bf -RF=Voltage={\em MV},harmonic={\em value}} --- Specify rf voltage and harmonic number.
\item {\bf -length={\em mm}} --- Specify the rms bunch length.
\item {\bf -energy={\em MeV}} --- Specify the beam energy.  By default, this is taken from
 the {\tt pCentral} parameter in {\em twissFile}.
\item {\bf -growthRatesOnly} --- If given, only the initial growth rates are computed.  Equilibrium
emittance values are not computed. {\em resultsFile} will contain columns of initial growth rate
contributions from individual elements. Without this option, {\em resultsFile}
would normally contain columns of growth rate contributions at equilibrium.
\item {\bf -integrate=turns={\em number}[,stepSize={\em number}]} --- 
  If given, then {\em resultsFile}
 contains the result of integrating the differential equations for the emittances for 
 the given number of turns and not the contributions 
 of individual elements of growth rates.  
 The step size is the number of turns for each integration step,
 and can be adjusted to get faster results.
 The options -growthRatesOnly and -integrate are not compatible.
\item {\bf -noWarning} --- Removes warning messages.
\end{itemize}

\item {\bf author:} A. Xiao, L. Emery, M. Borland, ANL/APS.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|madto|}\end{center}
\end{latexonly}
\subsection{madto}
\label{madto}

\begin{itemize}
\item {\bf description:} 
\verb|madto| translates an {\tt elegant}-style (or a MAD file, with
some restrictions) into formats accepted by other programs, such as COSY,
PARMELA, PATPET, PATRICIA, TRANSPORT, and XORBIT.  Will also generate
an SDDS file containing lattice data.

\item {\bf examples:}
The following command would translate the {\tt elegant} lattice file 
\verb|lattice.lte| into a TRANSPORT lattice file with 10mm quadrupole
aperture and 5mm sextupole aperture, at an energy of 1.5 GeV.
\begin{flushleft}{\tt
madto lattice.lte lattice.trin -transport=10,5,1.5
}\end{flushleft}

\item {\bf synopsis:}
\begin{flushleft}{\tt
madto {\em inputfile} {\em outputfile}
 \{-patricia | -patpet | -transport[={\em quadAper(mm)},{\em sextAper(mm)},{\em p(GeV/c)}]
            | -parmela[={\em quadAper(mm)},{\em sextAper(mm)},{\em p(GeV/c)}]
            | -sdds[={\em p(GeV/c)}] \
            | -cosy={\em quadAper(mm)},{\em sextAper(mm)},{\em p(MeV/c)} \
            | -xorbit\}
 [-angle\_tolerance={\em value}] [-flip\_k\_signs] [-magnets={\em filename}]
 [-header={\em filename}] [-ender={\em filename}]
}\end{flushleft}

\item {\bf files:}
\begin{itemize}
\item {\em inputfile} --- An {\tt elegant}-style lattice file.
\item {\em outputfile} --- A file containing lattice data in the chosen format.
\end{itemize}

\item {\bf switches:}
\begin{itemize}
\item {\bf -cosy} --- Provide data for the program COSY INFINITY.  This can take a little while
  as the program must figure out the Enge coefficients that correspond to the {\tt FINT} and
  {\tt HGAP} values for all the dipoles.  The user should test the output carefully.
\item {\bf -patricia} --- Provide data for the program PATRICIA.
\item {\bf -patpet} --- Provide data for the program PATPET, a merging of the programs
        PATRICIA and PETROS.
\item {\bf -transport[={\em quadAper(mm)},{\em sextAper(mm)},{\em p(GeV/c)}]} --- 
        Provide data for the program TRANSPORT (original style). 
	One may give apertures for
        the quadrupoles and sextupoles, as well as the beam momentum in GeV/c.
\item {\bf -parmela[={\em quadAper(mm)},{\em sextAper(mm)},{\em p(GeV/c)}]} --- 
        Provide data for the program PARMELA. One may give apertures for
        the quadrupoles and sextupoles, as well as the beam momentum in GeV/c.
\item {\bf -sdds[={\em p(GeV/c)}]} --- Provide data in SDDS form.  One may give the beam momentum in GeV/c.
\item {\bf -angle\_tolerance={\em value}}  --- PATPET and PATRICIA only allow sector and rectangular bends.
        This tolerance, in radians, determines how far from sector or rectangular a bend 
        definition may be and still get processed.
\item {\bf -flip\_k\_signs} --- Changes the signs of all quadrupoles.
\item {\bf -magnets={\em filename}} --- Results in output of an additional SDDS file with the magnet layout.
        This is the same file that would be generated by the {\tt magnets} field of the 
        {\tt run\_setup} command in {\tt elegant}.
\item {\bf -header={\em filename}}, {\bf -ender={\em filename}} --- 
        Allow specification of files to be prepended and appended to
        the lattice output.  For example, if additional commands are required prior to the
        lattice definition to set up the run, they would be put in the {\bf header} file.
        If additional commands are needed after the lattice definition to initiate processing, they 
        would be put in the {\tt ender} file.
\end{itemize}

\item {\bf author:} M. Borland, ANL/APS.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|sddsanalyzebeam|}\end{center}
\end{latexonly}
\subsection{sddsanalyzebeam}
\label{sddsanalyzebeam}

\begin{itemize}
\item {\bf description:} 
{\tt sddsanalyzebeam} analyzes a beam of macro-particles and produces an SDDS file
containing beam moments, emittances, equivalent beta functions, etc.  The beam file
is of the type written by {\tt elegant} using the {\tt output} field of the {\tt run\_setup}
command, or the WATCH element.

\item {\bf examples:}
\begin{flushleft}{\tt
sddsanalyzebeam run.out run.analysis 
}\end{flushleft}

\item {\bf synopsis:}
\begin{flushleft}{\tt
sddsanalyzebeam [-pipe=[input][,output]] [{\em inputfile}] [{\em outputfile}]
[-nowarnings] [-correctedOnly] [-canonical]
}\end{flushleft}

\item {\bf files:}
\begin{itemize}
\item {\em inputfile} --- An SDDS file containing the columns {\tt x}, {\tt xp}, {\tt y},
{\tt yp}, {\tt t}, and {\tt p}, giving the six phase-space coordinates for a set of macroparticles.
This file can be produced from {\tt elegant}, for example, using the {\tt output} field of the {\tt run\_setup} 
command, the {\tt bunch} field of the {\tt bunched\_beam} command, or the WATCH element in
coordinate mode.

\item {\em outputfile} --- An SDDS file containing columns giving
moments, emittances, equivalent Twiss parameters, and so on, for the
macro-particles.  Each row of this file corresponds to a page of the
input file.  The names and meanings of the columns are identical to
what is used for {\tt elegant}'s {\tt final} output file from the {\tt
run\_setup} command.  The file from {\tt elegant}, however, stores the
results as parameters instead of columns; to convert {\tt outputfile}
to that convention, use the SDDS toolkit program {\tt sddsexpand}.

\end{itemize}

\item {\bf switches:}
\begin{itemize}
\item {\tt pipe} --- The standard SDDS Toolkit pipe option.
\item {\tt nowarnings} --- Suppressses warning messages.
\item {\tt correctedOnly} --- If given, only the ``corrected'' twiss parameters and emittances are computed and
 output.  The corrected twiss parameters have the dispersive component subtracted.  Normally, these are
computed but given names like \verb|betacx|, \verb|ecx|, etc. whereas the uncorrected values are 
\verb|betax|, \verb|ex|, etc. The corrected parameters are the correct ones to match a beamline to, since they have the
 dispersive and mono-energetic terms properly separated.  The uncorrected values are more relevant if the dispersion
is spurious (i.e., uncorrected or due to something like CSR that doesn't admit of correction).
\item {\tt -canonical} --- If given, all computations are performed using canonical momenta 
  $q_x = p_x/p_0 = x^\prime (1 + \delta)/\sqrt{1 + x^{\prime 2} + y^{\prime 2}}$ etc.
\end{itemize}

\item {\bf author:} M. Borland, ANL/APS.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|sddsbrightness|}\end{center}
\end{latexonly}
\subsection{sddsbrightness}

\begin{itemize}
\item {\bf description:} {\tt sddsbrightness} computes undulator brightness curves using
Twiss parameter data from {\tt elegant} or {\tt sddsanalyzebeam}. Several calculation
methods are available.

\item {\bf examples:}
\begin{flushleft}{\tt
sddsbrightness run.twi run.bri -harmonics=3 -Krange=start=0.2,end=2.2,points=100 \\
  -current=0.1 -totalLength=2.4 -periodLength=0.027 -coupling=0.01

sddsanalyzebeam run.out -pipe=out -correctedOnly \\ 
 | sddsbrightness -pipe=in run.bri -harmonics=3 -Krange=start=0.2,end=2.2,points=100 \\
  -current=0.1 -totalLength=2.4 -periodLength=0.027 -coupling=0.01
}\end{flushleft}

\item {\bf synopsis:}
\begin{flushleft}{\tt
sddsbrightness [-pipe=[input][,output]] [{\em twissFile}] [{\em SDDSoutputfile}]
 -harmonics={\em integer} -Krange=start={\em value},end={\em value},points={\em integer}
 -current={\em Amps} -totalLength={\em meters} -periodLength={\em meters}
 [-emittanceRatio={\em value} | -coupling={\em value}] [-noSpectralBroadening]
 [-method={\em string},device={\em string},neks={\em value}]] 
}\end{flushleft}

\item {\bf files:}
\begin{itemize}
\item {\em twissFile} --- A Twiss output file from {\tt elegant}, with radiation integral 
calculations included, or an output from {\tt sddsanalyzebeam}. In the latter case, the
{\tt -correctedOnly} option should be used.
\item {\em SDDSoutputFile} --- Contains the brightness data in column form.  For each 
requested harmonic {\em i}, there are columns {\tt photonEnergy{\em i}}, {\tt wavelength{\em i}},
and {\tt Brightness{\em i}}.
\end{itemize}

\item {\bf switches:}
\begin{itemize}
\item {\tt pipe} --- The standard SDDS Toolkit pipe option.
\item {\tt harmonics} --- The number of harmonics to compute.
\item {\tt Krange=start={\em value},end={\em value},points={\em integer}} --- The range of the
 K parameter for the undulator and the number of points to compute on that range.
\item {\tt -current={\em Amps}} --- The current in amperes.  If one gives the average current,
 one gets the average brightness.  
\item {\tt -totalLength={\em meters}} --- The total length of the undulator, in meters.
\item {\tt -periodLength={\em meters}} ---  The period length of the undulator, in meters.
\item {\tt -emittanceRatio={\em value} | -coupling={\em value}} --- In the case of a twiss
 output file from {\tt elegant}, which does not contain the vertical emittance, one must
 supply one of these options.  If {\tt -emittanceRatio={\em R}} is given, $\epsilon_y = \epsilon_0*R$ 
 and $\epsilon_x = \epsilon_0$. If {\tt -coupling={\em k}} is given, $\epsilon_x = \epsilon_0/(1+k)$
 and $\epsilon_y = k*\epsilon_x$.  $\epsilon_0$ is the equilibrium emittance from the twiss output
 of {\tt elegant}.  

 In the case of twiss output from {\tt sddsanalyzebeam}, both emittances are present and these options
 are ignored.
\item {\tt -method={\em string},device={\em string},neks={\em value}]} --- Choose which method to
 use for brightness calculations.  Options are
 \begin{itemize} 
 \item {\tt borland} --- M. Borland's approximation method. Fast, but not as reliable as others.
 \item {\tt dejus} --- R. Dejus' non-zero emittance, infinite-N+convolution method.  This is the
   default.
 \item {\tt walkerinfinite} --- R. Walker's method.  Dejus' method is derived from this method.
 \item {\tt walkerfinite} --- R. Walker's method using finite N without convolution.  This is 
   quite slow.
 \end{itemize}
 The {\tt device} qualifier may be {\tt planar} or {\tt helical}.  {\tt neks} is used to 
 change the number of points used for finding the peak of the distribution.
\end{itemize}

\item {\bf authors:} M. Borland, H. Shang, R. Dejus (ANL).
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|sddsemitproc|}\end{center}
\end{latexonly}
\subsection{sddsemitproc}
\label{sddsemitproc}

\begin{itemize}

\item {\bf description:} 

{\tt sddsemitproc} analyzes quadrupole scan emittance measurement
data.  It accepts a file containing the transport matrix for each data
point and measured beam sizes.  Because {\tt sddsemitproc} uses the
matrix rather than a thin-lens model, it can analyze data from
arbitrarily complex scans, involving, for example, multiple thick-lens
quadrupoles.

The matrix data can be prepared using {\tt elegant}.  For example, the
{\tt vary\_element} command can be used to vary one or more
quadrupoles.  In addition, the beam size data may be prepared using
{\tt elegant}, to allow simulation of emittance measurements.

{\tt sddsemitproc} will perform error analysis using a Monte Carlo
technique.  A user-specified number of random error sets are generated
and added to all measurements.  Analysis is performed for each error
set.  Statistics over all the error sets provide most likely values
and error bars.

The beam parameters computed by {\tt sddsemitproc} pertain to the
beginning of whatever system is simulated in {\tt elegant}.

\item {\bf examples:}
\begin{flushleft}{\tt
elegant quadScan.ele
sddscollapse quadScan.fin -pipe=out \\
| sddsxref -pipe=in quadScan.data -take=SigmaX,SigmaY \\
| sddsemitproc -pipe=in emitResults.sdds
}\end{flushleft}

\item {\bf synopsis:}
\begin{flushleft}{\tt
sddsemitproc [{\em inputfile}] [{\em outputfile}] [-pipe=[input][,output]]
 [-sigmaData={\em xName},{\em yName}]
 [-errorData={\em xName},{\em yName} | 
  -errorLevel={\em valueInm},[\{gaussian,{\em nSigmas} | uniform\}]]
 [-nErrorSets={\em number}] [-seed=integer]
 [-limitMode={resolution | zero}[{,reject}]
 [-deviationLimit={\em xLevelm},{\em yLevelm}]
 [-resolution={\em xResolutionm},{\em yResolutionm}]
 [-verbosity={\em level}]
}\end{flushleft}

\item {\bf files:}
\begin{itemize}

\item {\em inputfile} --- An SDDS file containing one or more pages
with columns named \verb|R|{\em ij}, where {\em ij} is 11, 12, 33, and
34.  These give elements of the horizontal and vertical transport
matrices from the beginning of a system to the observation point.  The
sigma matrix inferred will be that for the beginning of the system.
Typically, one starts with the {\tt final} file from the {\tt
run\_setup} command in {\tt elegant}, and collapses it using {\tt
sddscollapse}.  Each page of {\em inputfile} corresponds to a different
emittance measurement.

In addition to this data, {\em inputfile} must also contain columns
giving the rms beam sizes in x and y.  The user supplies the names of
the columns using the \verb|-sigmaData| option; otherwise, they
default to \verb|Sx| and \verb|Sy|.  These columns may be from {\tt
elegant} (e.g., \verb|Sx| and \verb|Sy|), if one wants to simulate an
emittance measurement.  Note that the theory behind the emittance
measurement is strictly correct only for true RMS beamsize
measurements.  Use of FWHM or some other measure will give unreliable
results.
 
\item {\em outputfile} --- A file containing one page for each page of
{\em inputfile}.  The parameters of {\em outputfile} give the measured
geometric rms emittance, sigma matrix, and Twiss parameters of the 
beam in the horizontal and vertical planes.  If error sets were requested
(using \verb|-nErrorSets|), then there are also parameters giving the
error bars (``sigma's'') of the measured values.

\end{itemize}

\item {\bf switches:}
\begin{itemize}

\item {\tt -sigmaData={\em xName},{\em yName}} --- Supplies the names
of the columns in {\em inputfile} from which the x and y rms beam
sizes are to be taken.  Default values are {\tt Sx} and {\tt Sy},
which are the data provided by {\tt elegant}.

\item {\tt -errorLevel={\em valueInm},[{gaussian,{\em nSigmas} |
uniform}]} --- Supplies the standard deviation of random errors to be
added to the measured beam sizes for Monte Carlo error analysis.

\item {\tt -errorData={\em xName},{\em yName}} --- May be used to
supply the names of columns in the input file that contain the 
error level for each measurement.  This is an option instead of
using {\tt -errorLevel}, which allows varying the measurement
error for each point.

\item {\tt -nErrorSets={\em number}} --- The number of sets of random
errors to generate and add to the measurements.  Each error set is
used to perturb the original measurement data.  The results are
analyzed separately for each error set, then combined to give means
and error bars.

\item {\tt -seed=integer} --- Seed for the random number generator.
Recommend a large, positive, odd integer less than $2^31$.  If no seed
is given or if the given seed is negative, then a seed is generated
from the system clock.

\item {\tt -resolution={\em xResolutionm},{\em yResolutionm}} --- The
resolution of the beam size measurements, in meters.  These values are
subtracted in quadrature from the measured beam sizes to obtain the
true beam sizes.

\item {\tt -limitMode={resolution | zero}[,reject]} --- If measured or
perturbed beam sizes are less than the resolution or less than zero,
then errors will result.  One can use this option to limit minimum
beam size values or reject points.  In general, if one has to do this
the measurement is probably bad.

\item {\tt -deviationLimit={\em xLevelm},{\em yLevelm}} --- Specifies
the maximum deviation, in meters, from the fit that data points may
have and still be included.  An initial fit is performed for each
randomized set or the raw data, as appropriate.  Outliers are then
removed and the fit is repeated.

\item {\tt -verbosity={\em level}} --- Higher values of {\em level} result in more informational
        printouts as the program runs.
\end{itemize}

\item {\bf author:} M. Borland, ANL/APS.

\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|sddsfluxcurve|}\end{center}
\end{latexonly}
\subsection{sddsfluxcurve}

\begin{itemize}
\item {\bf description:} {\tt sddsfluxcurve} computes undulator fluxcurve curves using
Twiss parameter data from {\tt elegant} or {\tt sddsanalyzebeam}. Several calculation
methods are available.

\item {\bf examples:}
\begin{flushleft}{\tt
sddsfluxcurve run.twi run.bri -harmonics=3 \
  -electronBeam=current=0.1,coupling=0.01 \
  -undulator=period=0.033,numberOfPeriods=70,kmin=0.01,kmax=2.7,points=100 \
  -pinhole=distance=30,xsize=0.0025,ysize=0.001 
}\end{flushleft}

\item {\bf synopsis:}
\begin{flushleft}{\tt
sddsfluxcurve [-pipe=[input][,output]] [{\em twissFile}] [{\em SDDSoutputfile}]
    [-harmonics={\em integer}] [-method={\em methodName}[,neks={\em integer}]]
    [-mode={pinhole|density|total}]
    -undulator=period={\em meters},numberOfPeriods={\em integer},kmin={\em value},kmax={\em value}[,points={\em number}]
    [-electronBeam=current={\em amps},[,{coupling={\em value} | emittanceRatio={\em value}}]]
    [-pinhole=distance={\em meters},xsize={\em meters},ysize={\em meters}
    [,xnumber={\em integer}][,ynumber={\em integer}][,xposition={\em meters}][,yposition={\em meters}]]
    [-nowarnings]
}\end{flushleft}

\item {\bf files:}
\begin{itemize}
\item {\em twissFile} --- A Twiss output file from {\tt elegant}, with radiation integral 
calculations included, or an output from {\tt sddsanalyzebeam}. In the latter case, the
{\tt -correctedOnly} option should be used.
\item {\em SDDSoutputFile} --- Contains the flux data in column form.  For each 
requested harmonic {\em i}, there are columns {\tt photonEnergy{\em i}} and {\tt wavelength{\em i}},
plus a column for the flux ({\tt TotalFlux{\em i}}, {\tt PinholeFlux{\em i}}, or {\tt FluxDensity{\em i}}).
\end{itemize}

\item {\bf switches:}
\begin{itemize}
\item {\tt pipe} --- The standard SDDS Toolkit pipe option.
\item {\tt harmonics} --- The number of harmonics to compute.
\item {\tt -method={\em string},neks={\em value}]} --- Choose which method to
 use for calculations.   Options are
 \begin{itemize} 
 \item {\tt dejus} --- R. Dejus' non-zero emittance, infinite-N+convolution method.  This is the
   default.
 \item {\tt walkerinfinite} --- R. Walker's method.  Dejus' method is derived from this method.
 \end{itemize}
 {\tt neks} is used to  change the number of points used for finding the peak of the distribution.
\end{itemize}
\item {\tt mode={pinhole|density|total}} --- Specify whether to compute the flux through a pinhole, the flux density,
  or the total flux.
\item {\tt -undulator=period={\em meters},numberOfPeriods={\em integer},kmin={\em value},kmax={\em value}[,points={\em number}]} ---
  Specify undulator parameters.  {\tt points} is the number of K values to use on the interval $[K_{min}, K_{max}]$.
\item {\tt electronBeam=current={\em amps},[,{coupling={\em value} | emittanceRatio={\em value}}]} --- Specify parameters of the
  electron beam.  The current defaults to 0.1 A.  Either the coupling or emittance ratio must be given, unless the input file
  contains the parameter {\tt ey0} or the column {\tt ey}.
\item {\tt -pinhole=distance={\em meters},xsize={\em meters},ysize={\em meters}}{\tt [,xnumber={\em integer}]}\\
  {\tt [,ynumber={\em integer}]}{\tt [,xposition={\em meters}]}{\tt [,yposition={\em meters}]} ---
  Specify the parameters of the pinhole.  Required for {\tt -mode=pinhole}.  By default {\tt xnumber}=20, {\tt ynumber}=20, 
  {\tt xposition=0}, and {\tt yposition=0}.
\item {\bf authors:} M. Borland, H. Shang, R. Dejus (ANL).
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|sddsmatchtwiss|}\end{center}
\end{latexonly}
\subsection{sddsmatchtwiss}
\label{sddsmatchtwiss}

\begin{itemize}
\item {\bf description:} 
{\tt sddsmatchtwiss} transforms a beam of macro-particles to match to given beta
functions and dispersion.   This can be useful in taking macro-particle data from
one simulation and using it in another.  For example, a beam file from PARMELA
could be given the right beta functions for use with a specific lattice in an
{\tt elegant} run, saving the trouble of rematching to join the two simulations.
Similarly, a beam from {\tt elegant} could be matched into an FEL simulation.

\item {\bf examples:}
\begin{flushleft}{\tt
sddsmatchtwiss elegantBeam.out FELBeam.in -xPlane=beta=1.0,alpha=-0.2 -yPlane=beta=0.5,alpha=0.2
}\end{flushleft}

\item {\bf synopsis:}
\begin{flushleft}{\tt
sddsmatchtwiss [-pipe=[input][,output]] {\em inputfile} {\em outputfile}
[-xPlane=[beta={\em meters},alpha={\em value}][,etaValue={\em meters}][,etaSlope={\em value}]]
[-yPlane=[beta={\em meters},alpha={\em value}][,etaValue={\em meters}][,etaSlope={\em value}]]
[-nowarnings]
}\end{flushleft}

\item {\bf files:}

{\em inputfile} is an SDDS file containing one or more pages of data
giving the phase-space coordinates of macro particles.  The macro
particle data is stored in columns named \verb|x|, \verb|xp|,
\verb|y|, \verb|yp|, and \verb|p|.  The units are those used by {\tt
elegant} for the {\tt output} file from {\tt run\_setup}, the {\tt
bunch} file from {\tt bunched\_beam}, and the coordinate-mode output
from the {\tt WATCH} element. The data from these columns is used
together with the commandline arguments to produce new values for
these columns; the new values are delivered to {\tt outputfile}.
Other columns may be present in {\tt inputfile}; if so, they are
passed to {\em outputfile} unchanged.

\item {\bf switches:}
\begin{itemize}
\item {\tt -xPlane=[beta={\em meters},alpha={\em value}][,etaValue={\em meters}][,etaSlope={\em value}]} ---
        Specifies the desired parameters for the beam in the horizontal plane.  {\tt beta} and {\tt alpha} give
        $\beta$ and $\alpha = -\frac{1}{2}\frac{\partial \beta}{\partial s}$; they must both be given
        or both be omitted.  {\tt etaValue} and {\tt etaSlope} give the dispersion, $\eta$, and 
        its slope, $\frac{\partial \eta}{\partial s}$.
\item {\tt -yPlane=[beta={\em meters},alpha={\em value}][,etaValue={\em meters}][,etaSlope={\em value}]} ---
        Same as {\tt -xPlane}, except for the vertical plane.
\item {\tt -nowarnings} --- Suppresses warning messages.
\end{itemize}

\item {\bf author:} M. Borland, ANL/APS.
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|sddsrandmult|}\end{center}
\end{latexonly}
\subsection{sddsrandmult}
\label{sddsrandmult}

\begin{itemize}
\item {\bf description:} {\tt sddsrandmult} computes the multipole
errors in a quadrupole or sextupole due to various construction
errors.  The program is based on the analysis of
Halbach\cite{Halbach_69a}, with which I'll assume the reader is
familiar.  Instead of separately evaluating the effect of certain
types of mechanical errors, it allows one to simulate several types of
errors in order to get statistical distributions for the multipole
perturbations.

\item {\bf examples:}
\begin{flushleft}{\tt
sddsrandmult quadpert.in
}\end{flushleft}

\item {\bf synopsis:}
\begin{flushleft}{\tt
sddsrandmult {\em inputFile}
}\end{flushleft}

\item {\bf usage:}

{\em inputFile} is a text file containing a series of namelist commands specifying
the parameters of a quadrupole or sextupole, the type and amplitude of the errors
to include, and the filenames for output.  Each namelist command results in a
complete computation and generation of output files.

The namelist command is {\tt perturbations}.  It has the following fields:
\begin{itemize}
\item {\tt type} --- A string value, either ``quadrupole'' (default) or ``sextupole''.
\item {\tt name} --- An optional string value giving the name of the element.  This is
  used in preparing data for {\tt elegant}.
\item {\tt SDDS\_output} --- An required string value giving the name of an SDDS file to which
  data for each seed will be written.  This file can be used to compute statistics or perform
  histograms.
\item {\tt elegant\_output} --- An optional string value giving the name of a text file to which
  {\tt elegant} commands and element definitions will be written.  Note that this file is a mixture
  of commands and element definitions.  As such, the user must manually edit the file and place the
  appropriate parts in the lattice file and the command file.
\item {\tt kmult\_output} --- An optional string value giving the name of an SDDS file to which
  data will be written in the format accepted by the {\tt RANDOM\_MULTIPOLES} feature of the {\tt KQUAD}
  and {\tt KSEXT} elements.  {\em This is the recommended data to use with {\tt elegant}}.
\item {\tt effective\_length} --- The effective length of the magnet, in meters.
\item {\tt bore\_radius} --- The bore radius of the magnet, in meters.
\item {\tt dx\_pole} --- The rms error, in meters, to be imparted to the horizontal position of each pole.
\item {\tt dy\_pole} --- The rms error, in meters, to be imparted to the vertical position of each pole.
\item {\tt dradius} --- The rms error, in meters, in the bore radius.
\item {\tt dx\_split} --- The rms error, in meters, to be imparted to the horizontal distance between the
  left and right sides of the magnet.
\item {\tt dy\_split} --- The rms error, in meters, to be imparted to the vertical distance between the
  top and bottom halves of the magnet.
\item {\tt dphi\_halves} --- The rms error, in radians, to be imparted to the relative rotation of the top
  and bottom halves of the magnet.
\item {\tt n\_cases} --- The number of cases to simulate (default is 1000).
\item {\tt n\_harm} --- The number of harmonics to simulate.  The default is 0, which results in computing
 all the harmonics for which Halbach indicates his treatment applies.
\item {\tt random\_number\_seed} --- The initial seed for the random number generator.  Should be a large integer.
\end{itemize}

\item {\bf author:} M. Borland, ANL/APS.
\end{itemize}

\newpage
\begin{latexonly}
\newpage
\begin{center}{\Large\verb|sddsurgent|}\end{center}
\end{latexonly}
\subsection{sddsurgent}

\begin{itemize}
\item {\bf description:} {\tt sddsurgent} uses algorithms from the program
US (by R. Dejus) and URGENT (by R. Walker) for computation of undulator
radiation properties, including power density and intensity distributions.

\item {\bf examples:}
Take particle data from a tracking run and compute the power density using a 1 mm by 1 mm pinhole
for a 72-period, 3.3-cm-period undulator set for a 5 keV first harmonic.
\begin{flushleft}{\tt
sddsanalyzebeam run.out -pipe=out -correctedOnly \\ 
 | sddsurgent -pipe=in power.sdds -electronbeam=current=0.025 \\
 -calc=method=dejus,mode=powerDensity -us \\
 -pinhole=dist=30,xsize=1,ysize=1,xnum=100,ynum=100 \\
 -undulator=period=0.033,number=72,energy=5e3
}\end{flushleft}

\item {\bf synopsis:}
\begin{flushleft}{\tt
sddsurgent {\em inputFile} {\em outputFile}
    [-calculation=mode={\em modeString},method={\em methodString},harmonics={\em integer}] 
    [-undulator=period={\em meters},numberOfPeriods={\em integer},
      kx={\em value},ky={\em value},phase={\em value},energy={\em eV}] 
    [-electronBeam=current={\em Amp},energy={\em GeV},spread={\em fraction},
      xsigma={\em mm},ysigma={\em mm},xprime={\em mrad},yprime={\em mrad},nsigma={\em number}] 
    [-pinhole=distance={\em m},xposition={\em value},yposition={\em value},
      xsize={\em value},ysize={\em value},xnumber={\em integer},ynumber={\em integer}]
    [-alpha=steps={\em integer},delta={\em value}] 
    [-omega=steps={\em integer},delta={\em value}] [-nphi={\em integer}] 
    [-us] [-photonEnergy=maximum={\em eV},minimum={\em eV},points={\em number}]
    [-nowarnings] [-coupling={\em value} | -emittanceRatio={\em value}] 
}\end{flushleft}

\item {\bf files:}
\begin{itemize}
\item {\em inputFile} --- A Twiss output file from {\tt elegant}, with radiation integral 
calculations included, or an output from {\tt sddsanalyzebeam}. In the latter case, the
{\tt -correctedOnly} option should be used with {\tt sddsanalyzebeam}.
\item {\em outputFile} --- Contains the output data, which varies depending on the calculation mode.
 Use {\tt sddsquery} to view the file contents.
\end{itemize}

\item {\bf switches:}
\begin{itemize}
\item {\tt pipe} --- The standard SDDS Toolkit pipe option.
\item {\tt -calculation=mode={\em modeString},method={\em methodString},harmonics={\em integer}} ---
 Choose which calculation to perform and what method to us, as well as the number of undulator harmonics to
  compute.  Values for {\em modeString} are
  \begin{itemize}
    \item {\tt 1 | fluxDistribution}:        Angular/spatial flux density distribution.
    \item {\tt 2 | fluxSpectrum}:            Angular/spatial flux density spectrum
    \item {\tt 3 | brightness | brilliance}: On-axis brilliance spectrum
    \item {\tt 4 | pinholeSpectrum}:         Flux spectrum through a pinhole
    \item {\tt 5 | integratedSpectrum}:      Flux spectrum integrated over all angles
    \item {\tt 6 | powerDensity}:            Power density and integrated power
  \end{itemize}
  Values for {\em methodString} are
  \begin{itemize}
    \item 1:                    Non-zero emittance; finite-N.
    \item 2:                    Non-zero emittance; infinite-N.
    \item {\tt 3 | WalkerFinite}:   Zero emittance;     finite-N.
    \item {\tt 4  | Dejus}:           Non-zero emittance; infinite-N + convolution (Dejus, with {\tt -us} only).
    \item {\tt 14 | WalkerInfinite}:    Non-zero emittance; infinite-N + convolution (Walker, with {-tt us} only).
  \end{itemize}
\item {\tt -emittanceRatio={\em value} | -coupling={\em value}} --- In the case of a twiss
 output file from {\tt elegant}, which does not contain the vertical emittance, one must
 supply one of these options.  If {\tt -emittanceRatio={\em R}} is given, $\epsilon_y = \epsilon_0*R$ 
 and $\epsilon_x = \epsilon_0$. If {\tt -coupling={\em k}} is given, $\epsilon_x = \epsilon_0/(1+k)$
 and $\epsilon_y = k*\epsilon_x$.  $\epsilon_0$ is the equilibrium emittance from the twiss output
 of {\tt elegant}.  

 In the case of twiss output from {\tt sddsanalyzebeam}, both emittances are present and these options
 are ignored.
\item {\tt undulator=period={\em meters},numberOfPeriods={\em integer},}\\ {\tt kx={\em value},ky={\em value},phase={\em value},energy={\em eV}]} --- 
 Specify undulator parameters.  If energy (of first-harmonic photons) is given, {\tt kx=0} and {\tt ky} is computed,
 corresponding to a horizontally deflecting undulator.
 {\tt phase} specifies the phase difference in degrees for a canted undulator.  
\item {\tt -electronBeam=current={\em Amps},energy={\em GeV},spread={\em fraction},}\\ {\tt xsigma={\em mm},ysigma={\em mm},xprime={\em mrad},yprime={\em mrad},nsigma={\em number}} specifies electron beam parameters.  Only the current is needed, as other data will be drawn from the input file.
 \begin{itemize}
   \item {\tt current} ---  electron beam current in A. (default is 0.1A).
   \item {\tt energy} ---   electron energy in Gev. (default is 7.0Gev).
   \item {\tt spread} ---   electron energy spread.
   \item {\tt xsigma} ---   horizontal RMS beam size (mm)
   \item {\tt ysigma} ---   vertical RMS beam size (mm)
   \item {\tt xprime} ---   horizontal RMS divergence (mrad)
   \item {\tt yprime} ---   vertical RMS divergence (mrad)
   \item {\tt nsigma} ---   no. of standard deviations of electron beam dimensions
     (size and divergence) to be included.
 \end{itemize}
\item {\tt -pinhole=distance={\em m},xposition={\em value},yposition={\em value},}\\ {\tt xsize={\em value},ysize={\em value},xnumber={\em integer},ynumber={\em integer}} --- Specifies pinhole parameters.
  Pinhole parameters are not needed for computing on-axis brilliance (i.e., mode=3). 
  \begin{itemize}
    \item {\tt distance} ---   distance from the source (m)  (distance=0.0 gives angular flux).
    \item {\tt xposition} ---  X-coordinate for center of pinhole (mm) or (mrad for distance=0) 
    \item {\tt yposition} ---  Y-coordinate for center of pinhole (mm) or (mrad for distance=0) 
    \item {\tt xsize} ---      X-size of pinhole (full width)	(mm) or (mrad for distance=0) 
    \item {\tt ysize} ---      y-size of pinhole (full width)	(mm) or (mrad for distance=0) 
    \item {\tt xnumber} ---    Number of subdivisions of pinhole in X (max 500) 
    \item {\tt ynumber} ---    Number of subdivisions of pinhole in Y (max 500) 
  \end{itemize}
\item {\tt nphi={\em number}} --- Specifies number of steps in phi between 0 and $\pi/2$. Must be less than 100.
  used in (calculation mode=1,2,3,4,5 calculation method=1,2).
\item {\tt alpha=steps={\em integer},delta={\em value}} --- Specifies the number of steps in angle alpha (gamma*theta) (<100). 
            Delta specifies range of angles in alpha$^2$ to be used, in units of 
            the angular equivalent to 1/N. Used in  (mode=1, method=1) and method=3.
\item {\tt omegasteps={\em integer},delta={\em value}} ---   Specifies the number of steps in 
            photon energy for the natural lineshape (<5000). 
            delta specifies range of photon energies to be included in the natural lineshape 
            in units (energy of fundamental/N).  The default value covers the range $\pm 2/N$
            of the natural lineshape. 
            Used in mode=2,3,4,5 method=1. 
\item {\tt photonEnergy=maximum={\em eV},minimum={\em eV},points={\em number}} --- 
  Specifies the maximum and minimum photon energy in eV, 
  and the number of energy points to be computed.
\end{itemize}

\item {\bf authors:} H. Shang, R. Dejus, M. Borland, X. Jiao (ANL).
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|smoothDist6|}\end{center}
\end{latexonly}
\subsection{smoothDist6}

\begin{itemize}
\item {\bf description:} Increases the number of particles in a particle input file by
 sampling a simplified distribution based the input file.  Intended to be used to increase the number of particles
 produced by a photoinjector simulation to improve stability of CSR and LSC simulations.
 Can also add energy and density modulations for performing gain studies.

The algorithm is as follows:
\begin{enumerate}
\item Fit a 12$^{th}$-order polynomial to $p$ as a function of $t$.  Evaluate
 the polynomial at 10,000 equispaced points to generate a lookup table for the momentum
 variation with time.
\item Compute the standard deviation of the momentum $p_{sd}$ for blocks of 2,000 successive
 particles.  Fit this data with a 12$^{th}$-order polynomial and evaluate 
 it a 10,000 equispaced points to generate a lookup table for $p_{sd}$ as a function of $t$.
\item Create a histogram of $t$ and smooth it with a low-pass filter having a cutoff at
 0.1 THz.  This may resulting in ringing at the ends of the histogram, which is clipped off
 by masking with the original histogram. 
\item Optionally modulate the histogram H(t) with a sinusoid, by
 multiplying the histogram by $(1 + d_m) \cos 2\pi c t/\lambda_m$, where $d_m$
 is the modulation depth and $\lambda_m$ is the modulation wavelength. For non-zero $d_m$,
 this will result in a longitudinal-density-modulated distribution when the histogram is
 used as a probability distribution and sampled to create time coordinates.
\item Sample the time histogram $N$ times using a ``quiet start'' Halton sequence with
 radix 2, where $N$ is the number of desired particles.  The sampling
 operation is performed by first numerically computing the cumulative
 distribution function $C(t)=\int_{-\infty}^t H(t^\prime)
 dt^\prime/\int_{-\infty}^\infty H(t^\prime) dt^\prime$.  Inverting
 this to obtain $t(C)$, we generate each sample from $H(t)$ by
 evaluating $t(U)$, where $U$ is a quantity on the interval [0, 1] generated
 from the Halton sequence.
\item Create samples for other coordinates by quiet-sampling of gaussian distributions:
 \begin{enumerate}
 \item Scaled transverse coordinates $\hat{x}$, $\hat{x^\prime}$,
 $\hat{y}$, and $\hat{y^\prime}$ using Halton radices 3, 5, 7, and 11,
 respectively.  For convenience in scaling (step 9), these are defined such that the standard deviation of
 each coordinate is $10^{-4}$ and all coordinates are uncorrelated.
 \item Scaled fractional momentum deviation $\delta_1$ using Halton radix 13, with
 unit standard deviation.
 \end{enumerate}
\item Interpolate the look-up tables to determine the mean $p_{mean}$ and standard 
 deviation $p_{sd}$ of the momentum at each particle's time coordinate. Use these
 to compute the individual particle momenta using $p = p_{mean} + \delta_1 p_{sd}$.
\item Compute the projected transverse rms emittances and Twiss parameters for the original beam.
\item Transform the scaled transverse phase-space coordinates to give the desired 
 projected Twiss parameters in the x and y planes.  The x and y planes are assumed to be uncorrelated.
\end{enumerate}

\item {\bf synopsis:}
\begin{flushleft}{\tt
smoothDist6 -input {\em name} -output {\em name} -factor {\em number} -rippleAmplitude {\em \%} -rippleWavelength {\em microns} \
 -smoothPasses {\em num(500)} -energyMod {\em \%} -betaSlices {\em n}
}\end{flushleft}

\item {\bf files:}
\begin{itemize}
\item {\tt input} --- A particle distribution file, such as might be used with \verb|sdds_beam|.
\item {\tt output} --- A particle distribution file, such as might be used with \verb|sdds_beam|.
\end{itemize}

\item {\bf switches:}
\begin{itemize}
\item {\tt -factor {\em number}} --- Factor by which to multiply the number of particles.
\item {\tt -rippleAmplitude {\em value}} --- Density ripple amplitude, in percent.
\item {\tt -energyMod {\em value}} --- Energy modulation amplitude, in percent.  The wavelength is fixed at 1 $\mu$m.
\item {\tt -rippleWavelength {\em value}} --- Density ripple and energy modulation wavelength, in microns.
\item {\tt -betaSlices {\em n}} --- Number of longitudinal slices to use for analysis of twiss parameters.  The twiss parameters of 
the beam will vary step-wise from slice to slice.  This discontinuous variation may cause problems (e.g., unstable behavior).
\item {\tt -smoothPases {\em num}} --- Presently ignored.
\end{itemize}

\item {\bf author:} M. Borland, ANL/APS.

\item {\bf see also:} {\tt doubleDist6}
\end{itemize}

\begin{latexonly}
\newpage
\begin{center}{\Large\verb|touschekLifetime|}\end{center}
\end{latexonly}
\subsection{touschekLifetime}

\begin{itemize}

\item {\bf description:} \verb|touschekLifetime| computes Touschek lifetime using 
A. Piwinski's formula \cite{Piwinski, Xiao2007a}.

\item {\bf examples:}
\begin{flushleft}{\tt
touschekLifetime aps.life -twiss=aps.twi -aper=aps.aper -part=2e10 -coupling=0.01 -length=6
}\end{flushleft}

\item {\bf synopsis:}
\begin{flushleft}{\tt 
touschekLifetime {\em outputFile}
 -twiss=<twissFile> -aperture=<momentumApertureFile>
 {-charge=<nC>|-particles=<value>} -coupling=<value>
 {-RF=Voltage=<MV>,harmonic=<value>|-length=<mm>} 
 [-emitxInput=<value>] [-deltaInput=<value>] [-verbosity=<value>]
 [-ignoreMismatch] [-deltaLimit=<value>]
}\end{flushleft}

\item {\bf files:}
{\em outputFile} --- Contains resulting Touschek lifetime.

\item {\bf switches:}
\begin{itemize}
\item {\tt -twiss} --- A twiss parameter file from {\tt elegant}. 
You must use the \verb|radiation_integrals| flag in \verb|twiss_output|.
\item {\tt -aperture} --- A momentum aperture file from {\tt elegant}.
This file can contain a subset of elements of twissFile (for example:
only Quadrupole elements).  However, the Twiss and momentum aperture
files {\em must} cover the same beamline. Having one file for a part
of beamline (e.g., a few sectors) and one for the entire ring will
yield incorrect results.
\item {\tt -charge}, {\tt -particles} --- Give the charge (in nanocoulombs) or the
 number of electrons.
\item {\tt -coupling} --- Give the emittance coupling ratio, $\epsilon_y/\epsilon_x$.  This is
 used to compute the horizontal and vertical emittance from the natural emittance.
\item {\tt -RF=Voltage={\em MV},harmonic={\em value}} --- Specify rf voltage and harmonic number.
 N.B.: If the data files cover only a portion of the ring, using this option will give incorrect results!
\item {\tt -length={\em mm}} --- Specify the rms bunch length.  This is an alternative to giving rf parameters.
\item {\tt -emitxInput} --- Give the initial x emittance in meters.  If not specified,
the value from the parameter \verb|ex0| in {\em twissFile} is used.
\item {\tt -deltaInput} --- Give the initial rms fractional momentum spread.  If not
specified, the value from the parameter \verb|Sdelta0| in {\em twissFile} is used.
\item {\tt -verbosity} --- If nonzero, program execution information is printed to the standard output.
\item {\tt -ignoreMismatch} --- If given, then mismatch of element names between the twiss and momentum
  aperture files is ignored.  May be useful if there are zero-length elements.
\item {\tt -deltaLimit} --- Give the maximum value for the momentum aperture.  If not specified,
  the values in the momentum aperture input file are used unaltered.
\end{itemize}

\item {\bf author:} A. Xiao, ANL/APS.

\end{itemize}

\newpage 

\section{Accelerator and Element Description}

As mentioned in the introduction, {\tt elegant} uses a variant of the
MAD input format for describing accelerators.  With some exceptions,
the accelerator description for one program can be read by the other
with no modification.  Among the differences:
\begin{itemize}
\item {\tt elegant} does not support the use of MAD-style equations to compute
the value of a quantity.  The \verb|link_elements| namelist command
can be used for this purpose, and is actually more flexible than the
method used by MAD.  Also, \verb|rpn|-style equations may be given
in double-quotes; these are evaluated once only when the lattice
is parsed.
\item {\tt elegant} does not support substitution of parameters in
beamline definitions.
\item {\tt elegant} contains many elements that MAD does not have, such
as kick elements, wake fields, and numerically integrated elements.
\item The length of an input line is not limited to 80 characters in 
{\tt elegant}, as it is in MAD.  However, for compatibility, any lattice
created by {\tt elegant} will conform to this limit.
\item The maximum length of the name of an element or beamline is 100 characters.
\end{itemize}

{\tt elegant}'s lattice parser translates all input into upper case,
except where the input is protected by double quotes.  However,
various commands (such as {\tt vary\_element} or {\tt link\_elements})
that accept element names as input do not perform any translation.
Hence, when referring to element names in commands, the user must
enter the names in upper case unless they are protected by double
quotes in the lattice file.  

The rules for naming elements and beamlines are as follows:
\begin{itemize}
\item The name should start with an alphabetic character (i.e., a-z A-Z).
\item The name may contain any of the following characters in addition to
alphabetic characters and numbers: 
\verb#~ @ $ % ^ & - _ + = { } [ ] \ | / ? < > . : |\verb#
\item The name should not contain any of the following: \verb|# * ! `` ' `|
\item The name should not contain spaces, tabs, or non-printing characters.
\end{itemize}
If using unusual characters in a name, it is a good idea to enclose the name
in double quotes.   This is required if \verb|:| is in the name.

{\tt elegant}'s \verb|print_dictionary| command allows the user to
obtain a list of names and short descriptions of all accelerator
elements recognized by the program, along with the names, units,
types, and default values of all parameters of each element. 
The present output of this command is listed in the next section.
The reader is referred to the MAD manual\cite{MAD} for details on sign
conventions for angles, focusing strength, and so forth.  

Comments may be embedded in the lattice file by starting a line with 
an exclamation point (``!'').  Rpn expressions may be embedded separately
from an element definition by starting a line with a percent sign (``\%'').
For example
\begin{verbatim}
! Define pi
% 1 atan 4 * sto Pi
% Pi 40 / sto myAngle
! Define a rectangular bend for a ring with 80 equal bends
B1: SBEN,L=1.0,ANGLE=''myAngle'',E1=''myAngle 2 /'',E2=''myAngle 2 /''
\end{verbatim}
(Note that {\tt pi} is already defined in the standard {\tt defns.rpn} file.)

\newpage
\section{Element Dictionary}
\include{dictionary}

\newpage
\section{Examples}

Example runs and post-processing files are available in a separate tar file.
The examples are intended to
demonstrate program capabilities with minimal work on the user's part.
However, they don't pretend to cover all the capabilities.

Each demo is (typically) invoked using a command (usually a C-shell
script) that can both run {\tt elegant} and post-process the output.
The post-processing is often handled by a lower-level script that is
called from the demo script.  These lower-level scripts are good
models for the creation of customized scripts for user applications.

The examples are organized into a number of directories and subdirectories.
In each area, the user will find a ``Notebook'' file (a simple ASCII file) that describes 
the example and how to run it.

Many examples for storage ring simulations reside in the {\tt PAR} subdirectory.
The PAR (Particle Accumulator Ring) is a small storage ring in the APS injector
that is good for quick examples because of its size.

Here's a helpful tip in searching the examples on UNIX/LINUX systems: suppose one wants
to find an example of the \verb|frequency_map| command.  One can search all the elegant
command files very quickly with this command:
\begin{verbatim}
find . -name '*.ele' | xargs fgrep frequency_map
\end{verbatim}
Similarly, to find all examples that use \verb|CSBEND| elements, one could use
\begin{verbatim}
find . -name '*.lte' | xargs fgrep -i csbend
\end{verbatim}


\newpage
\section{The {\tt rpn} Calculator}

The program {\tt rpn} is a Reverse Polish Notation programmable
scientific calculator written in C.  It is incorporated as a
subprogram into {\tt elegant}, and a number of the SDDS programs.  It
also exists as a command-line program, {\tt rpnl}, which executes its
command-line arguments as {\tt rpn} operations and prints the result
before exiting.  Use of {\tt rpn} in any of these modes is extremely
straightforward.  Use of the program in its stand-alone form is the
best way to gain familiarity with it.  Once one has entered {\tt rpn},
entering ``help'' will produce a list of the available operators with
brief summaries of their function.  Also, the {\tt rpn} definitions
file \verb|rpn.defns|, distributed with {\tt elegant}, gives examples
of most {\tt rpn} operation types.

Like all RPN calculators, {\tt rpn} uses stacks.  In particular, it
has a numeric stack, a logical stack, and a string stack.  Items are
pushed onto the numeric stack whenever a number-token is entered, or
whenever an operation concludes that has a number as its result; items
are popped from this stack by operations that require numeric
arguments.  Items are pushed onto the logical stack whenever a logical
expression is evaluated; they are popped from this stack by use of
logical operations that require logical arguments (e.g., logical
ANDing), or by conditional branch instructions.  Items enclosed in
double quotes are pushed onto the string stack; items are popped from
this stack by use of operations that require string arguments (e.g.,
formatted printing).

{\tt rpn} supports user-defined memories and functions.  To create a
user-defined memory, one simply stores a value into the name, as in
``1 sto unity''; the memory is created automatically when {\tt rpn}
detects that it does not already exist.  To create a user-defined
function, enter the ``udf'' command; {\tt rpn} will prompt for the
function name and the text that forms the function body.  To invoke a
UDF, simply type the name.

A file containing {\tt rpn} commands can be executed by pushing the
filename onto the string stack and invoking the ``@'' operator.  {\tt
rpn} supports more general file I/O through the use of functions that
mimic the standard C I/O routines.  Files are identified by integer
unit numbers, with units 0 and 1 being permanently assigned to the
terminal input and terminal output, respectively.

\newpage
\begin{thebibliography}{9}

\bibitem{Kernighan}
    B. W. Kernighan and D. M. Ritchie, {\em The C Programming Language},
    Prentice-Hall, Englewood Cliffs, N.J., second edition, 1988.

\bibitem{MAD}
    H. Grote, F. C. Iselin, ``The MAD Program--Version 8.1,'' CERN/SL/90-13(AP), June 1991.

\bibitem{KLBrown}
    K. L. Brown, R. V. Servranckx, ``First- and Second-Order Charged Particle Optics,'' 
    SLAC-PUB-3381, July 1984.

\bibitem{Borland_thesis}
    M. Borland, ``A High-Brightness Thermionic Microwave Electron Gun,'' SLAC-Report-402,
    February 1991, Stanford University Ph.D. Thesis.

\bibitem{Enge}
    H. A. Enge, ``Achromatic Mirror for Ion Beams,'' Rev. Sci. Inst., 34(4), 1963.

\bibitem{Borland_PC}
    M. Borland, private communication.

\bibitem{Numerical_Recipes}
    W. H. Press, {\em et al}, {\em Numerical Recipes in C}, Cambridge University
    Press, Cambridge, 1988.

\bibitem{SDDS1}
M. Borland, ``A Self-Describing File Protocol for Simulation
Integration and Shared Postprocessors,'' Proc. 1995 PAC, May 1-5,
1995, Dallas, Texas, pp. 2184-2186 (1996).

\bibitem{SDDS2}
M. Borland, ``A Universal Postprocessing Toolkit for Accelerator 
Simulation and Data Analysis,'' Proc. 1998 ICAP Conference, 
Sept. 14-18, 1998, Monterey, California, to be published.

\bibitem{DQS} T. P. Green, ``Research Toward a Heterogeneous Networked
Computer Cluster: The Distributed Queuing System Version 3.0,'' SCRI
Technical Publication, 1994.

\bibitem{S2EJitter} M. Borland {\em et al}, ``Start-to-End Jitter Simulation
of the LCLS,'' Proceedings of the 2001 Particle Accelerator Conference,
Chicago, 2001.

\bibitem{TopUpTracking} M. Borland and L. Emery, ``Tracking Studies of
Top-Up Safety for the Advanced Photon Source,'', Proceedings of the
1999 Particle Accelerator Conference, New York, 1999, pg 2319-2321.

\bibitem{MingXie} M. Xie, ``Free Electron Laser Driven by SLAC
LINAC''.

\bibitem{GENESIS} S. Reiche, {\em NIM} A 429 (1999) 242.

\bibitem{BM}
  J.D. Bjorken, S.K. Mtingwa, ``Intrabeam Scattering,'' Part. Acc. Vol. 13, 
  1983, 115-143.

\bibitem{Halbach_69a}
    K. Halbach, ``First Order Perturbation Effects in Iron-Dominated Two-Dimensional Symmetrial Multipoles'',
    NIM {\bf 74-1}, 1969, 147-164.

\bibitem{Jackson}
  J. D. Jackson, {\em Clasical Electrodynamics}, second edition.

\bibitem{Ripken}
 G. Ripken, DESY Report No. R1-70/04, 1970 (unpublished).

\bibitem{HAPE}
  {\em Handbook of Accelerator Physics and Engineering}, A. Chao and M. Tigner eds., 1998.

\bibitem{Derbenev}
  Ya. S. Derbenev, J. Rossbach, E. L. Saldin, V. D. Shiltsev, ``Microbunch Radiative Tail-Head
  Interaction,'' September 1995, TESLA-FEL 95-05.

\bibitem{Xiao2007A}
  A. Xiao {\em et al.}, ``Direct Space-Charge Calculation in {\tt elegant} and its Application to the
 ILC Damping Ring,'' Proc. PAC2007, 3456-3458.

\bibitem{Huang2004}
  Z. Huang {\em et al.}, Phys. Rev. ST Accel. Beams {\bf 7} 074401 (2004).

\bibitem{Piwinski}
  A. Piwinski, `` The Touschek effect in strong focusing storage rings,'' DESY-98-179, Nov 1998.

\bibitem{Xiao2007a}
  A. Xiao {\em et al.}, ``Touschek Effect Calculation and its Application to a Transport Line,''
  Proc. PAC07, 3453-3455 (2007).

\bibitem{Warnock}
  W. Warnock, ``Shielded Coherent Synchrotron Radiation and Its Effect on Very Short Bunches,'' SLAC-PUB-5375, 1990.

\bibitem{Agoh}
  T. Agoh and K. Yokoya, ``Calculation of coherent synchrotron radiation using mesh,'' Phys. Rev. ST Accel. Beams 7,
  054403 (2004).

\bibitem{Elleaume1992}
  P. Elleaume, ``A New Approach to Electron Beam Dynamics in Undulators and Wigglers,'' Proc. EPAC 1992, 661-663.

\bibitem{radia}
  http://www.esrf.eu/Accelerators/Groups/InsertionDevices/Software/Radia

\bibitem{Bengtsson}
 J. Bengtsson, "The Sextupole Scheme for the Swiss Light Source (SLS): An Analytic Approach," SLS Note 9/97,
 March 7, 1997. (Corrections to several typos were supplied by W. Guo, NSLS.)

\bibitem{ASTRA}
  K. Fl\"{o}ttmann, Astra User Manual, http://www.desy.de/~mpyflo/Astra\_dokumentation/

\bibitem{IMPACT}
J. Qiang {\em et al.},  J.~Comp.~Phys. 163, 434 (2000).

\bibitem{TRACK}
  V. N. Aseev {\em et al.}, Proc. PAC05, 2053-2055 (2005); ASCII version 39 from B. Mustapha.

\bibitem{Chi2005}
  H. Chi {\em et al.}, Mathematics and Computers in Simulation {\bf 70} (2005) 9-21.

\end{thebibliography}

\end{document}
